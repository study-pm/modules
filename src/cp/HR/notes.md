Data-driven approach

Security

Test design

Многоязыковая поддержка

Описать структуру проекта, назначение каталогов

Концепции, архитектурные решения, шаблоны

https://www.perplexity.ai/search/u-menia-v-wpf-est-proverka-par-7KRQL8akRbqO7Y3P02EHMw

1. Проверка пароля в `PasswordBox`

    Вы уже используете свойство `Password` элемента `PasswordBox` для получения введённого пароля и проверки его регулярным выражением. Это стандартный и безопасный подход.

2. Хранение пароля в базе данных

    `SecureString` — это класс .NET для безопасного хранения строковых данных (например, паролей) в памяти. Однако, `SecureString` не предназначен для хранения в базе данных (в том числе MS SQL Server), так как его нельзя сериализовать и сохранить в виде строки или двоичных данных напрямую.

    Рекомендуемый подход — хранить хеш пароля (например, с помощью алгоритма PBKDF2, bcrypt или Argon2). В этом случае в базу данных сохраняется только хеш, а сам пароль нигде не хранится. Это максимально безопасно.

3. Сравнение паролей при аутентификации

    Когда пользователь вводит пароль, вы получаете его из `PasswordBox.Password`, хешируете (используя тот же алгоритм и параметры, что и при сохранении), и сравниваете полученный хеш с тем, что хранится в базе данных. Если хеши совпадают — пароль верный.

4. Использование Entity Framework

    Entity Framework не имеет специальных средств для работы с `SecureString`. Вы должны передавать пароль в виде обычной строки для хеширования (или использовать специальные библиотеки, которые умеют работать с `SecureString` напрямую, но это уже редкость).

**Важно**: Никогда не храните пароли в открытом виде в базе данных. Используйте только хеши.

Пример кода
```cs
// Получение пароля из PasswordBox
string password = passwordBox.Password;

// Хеширование пароля (пример с PBKDF2)
byte[] salt = GenerateSalt();
byte[] hash = HashPassword(password, salt);

// Сохранение salt и hash в базу данных

// Проверка пароля при входе
bool isPasswordValid = VerifyPassword(enteredPassword, storedSalt, storedHash);
```

Итоги
- `SecureString` не подходит для хранения в базе данных — используйте хеши.

- Проверяйте пароль из `PasswordBox.Password` на соответствие регулярному выражению.

- Сравнивайте хеши паролей при аутентификации.

- EntityFramework работает с обычными строками и бинарными данными, но не с `SecureString` напрямую.

Если вы хотите максимально безопасно работать с паролями, используйте хеширование и никогда не храните пароли в открытом виде.

Вам не обязательно устанавливать дополнительные сторонние инструменты для хеширования паролей, генерации соли (salt) и создания хеша в .NET. Встроенных средств достаточно для большинства задач:

- Генерация соли:

    Вы можете использовать класс `RandomNumberGenerator` из пространства имён `System.Security.Cryptography` для создания криптографически безопасной соли.

    Пример:
    ```cs
    byte[] salt = new byte[16];
    using (var rng = RandomNumberGenerator.Create())
    {
        rng.GetBytes(salt);
    }
    ```

- Хеширование пароля:

    Для хеширования пароля подойдут такие алгоритмы, как PBKDF2 (рекомендуется), доступные через класс `Rfc2898DeriveBytes` (или `Rfc2898DeriveBytes.Pbkdf2` в .NET 5+).

    Пример:
    ```cs
    using (var pbkdf2 = new Rfc2898DeriveBytes(password, salt, iterations: 10000, hashAlgorithm: HashAlgorithmName.SHA256))
    {
        byte[] hash = pbkdf2.GetBytes(32); // например, 32 байта для хеша
    }
    ```

- Сравнение паролей:

    Для сравнения введённого пароля с сохранённым хешем используйте тот же алгоритм и соль, что и при регистрации.

**Вывод**: Дополнительные библиотеки или инструменты не требуются, если вы используете современные версии .NET и стандартные алгоритмы хеширования. Если вы хотите использовать более современные алгоритмы (например, Argon2 или bcrypt), тогда может потребоваться сторонняя библиотека, но для большинства задач хватает встроенных возможностей.

Если вы используете .NET Framework 4.7.2, то для хеширования паролей и генерации соли доступны стандартные криптографические классы, такие как `Rfc2898DeriveBytes` (рекомендуется для хеширования паролей), `RandomNumberGenerator` (для генерации соли) и другие алгоритмы из пространства имён `System.Security.Cryptography`.

Вам не требуется устанавливать дополнительные инструменты для выполнения этих задач. Всё необходимое уже встроено в .NET Framework 4.7.2. Например, для хеширования пароля можно использовать следующий подход:
```cs
using System.Security.Cryptography;

byte[] salt = new byte[16];
using (var rng = RandomNumberGenerator.Create())
{
    rng.GetBytes(salt);
}

using (var pbkdf2 = new Rfc2898DeriveBytes(password, salt, 10000))
{
    byte[] hash = pbkdf2.GetBytes(32); // 32 байта — длина хеша
}
```

Также поддерживается использование класса `PasswordDeriveBytes`, но он считается менее безопасным по сравнению с `Rfc2898DeriveBytes`.

**Вывод**: Достаточно использовать стандартные классы .NET Framework 4.7.2 для хеширования паролей и генерации соли. Дополнительные пакеты не требуются.

Для хранения локальных предпочтений пользователя, логов действий и другой информации, которую вы не хотите хранить в базе данных, можно использовать как XML, так и JSON. Оба формата подходят для большинства задач, но выбор зависит от ваших предпочтений и специфики работы с данными.

### Сравнение XML и JSON
| Критерий           | XML                                                         | JSON                                                               |
| ------------------ | ----------------------------------------------------------- | ------------------------------------------------------------------ |
| Читаемость         | Менее компактный, более структурированный                   | Более компактный и понятный для разработчиков                      |
| Поддержка в .NET   | Встроенные классы (XmlSerializer, XDocument)                | Встроенные классы (System.Text.Json, Newtonsoft.Json)              |
| Гибкость структуры | Поддерживает сложные структуры, атрибуты, пространства имён | Проще для простых иерархий, не поддерживает атрибуты и комментарии |
| Доступность        | Подходит для конфигураций, логов с метаданными              | Подходит для большинства пользовательских настроек и логов         |

### Рекомендации
- Для настроек пользователя и небольших логов чаще всего используют JSON из-за простоты чтения, редактирования и компактности. В .NET доступны библиотеки `System.Text.Json` (встроена в современные версии) и `Newtonsoft.Json` (для более старых проектов и более широких возможностей).

- Для хранения сложных данных с метаданными, атрибутами или необходимостью валидации по схеме может быть удобнее XML. Однако для большинства задач WPF-приложений это избыточно.

- Для логов действий можно использовать и JSON, и XML, но JSON проще для автоматической обработки и анализа.

### Где хранить файлы
Рекомендуется хранить такие файлы в специальном каталоге приложения, например, в папке *AppData* текущего пользователя (*%APPDATA%\YourAppName*), чтобы обеспечить изоляцию данных и корректную работу при обновлении или удалении приложения.

В .NET для этого удобно использовать `Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)`.

Итог
- JSON — оптимальный выбор для хранения настроек и логов в большинстве WPF-приложений.

- XML — стоит использовать, если нужна сложная структура или поддержка схемы.

- Храните файлы в *AppData* для корректной работы приложения и безопасности данных.

Если у вас нет особых требований к структуре данных, выбирайте JSON.

.NET Framework 4.7.2 не имеет встроенной поддержки JSON как часть стандартной библиотеки в том виде, как это реализовано в .NET Core 3.0 и выше (там есть пространство имён `System.Text.Json` по умолчанию). Однако вы можете добавить поддержку JSON в свой проект на .NET Framework 4.7.2 с помощью сторонних библиотек или установить NuGet-пакет `System.Text.Json`, который доступен для .NET Framework 4.7.2 и поддерживает сериализацию и десериализацию JSON.

Также широко используется библиотека `Newtonsoft.Json` (Json.NET), которая долгое время была стандартом де-факто для работы с JSON в .NET Framework и поддерживает все его версии.

**Итог**: Встроенной поддержки JSON в .NET Framework 4.7.2 нет, но вы можете легко добавить её через NuGet-пакеты:

- **`System.Text.Json`** (современный, производительный, доступен для .NET Framework 4.7.2)

- **`Newtonsoft.Json`** (очень популярная, богатая функциональностью)

Оба варианта подходят для работы с JSON в WPF-приложении на .NET Framework 4.7.2.

Изображения могут храниться в БД как отдельно имена, так и имена с файловым расширением или в виде абсолютных путей.

Реализовано универсальное автоматическое рекурсивное сравнение всех публичных свойств объектов с помощью рефлексии. Такой метод позволяет сравнить два объекта по значению, включая вложенные объекты, без необходимости вручную писать сравнение для каждого типа. Установка статусов IsInProgress.

## Предпочтения
Для чтения и записи предпочтений пользователя из XML-файла, нужно реализовать методы, которые будут:

- Загружать настройки из XML-файла в объект `PreferencesViewModel`.

- Сохранять текущие настройки из `PreferencesViewModel` в XML-файл.

Да, методы для чтения и записи XML вполне можно перенести непосредственно в модель `UserPreferences`. Это распространённый подход, который позволяет инкапсулировать логику сериализации и десериализации внутри самого класса данных, упрощая использование и улучшая читаемость кода.

Пояснения:

- Статический метод `LoadAsync` загружает настройки из XML-файла и возвращает объект `UserPreferences`.

- Метод экземпляра `SaveAsync` сохраняет текущий объект в XML.

- Используется `XmlSerializer` из пространства имён `System.Xml.Serialization`, который сериализует публичные свойства класса в XML и обратно.

- Асинхронность достигается через `Task.Run`, чтобы не блокировать UI-поток при работе с файловой системой.

Теперь при загрузке страницы настройки будут загружаться из файла *user_preferences.xml*, а при сохранении — записываться туда же.

Если файл отсутствует, используется значение по умолчанию (в примере — `false` для `IsStayLoggedIn`). Вы можете изменить этот путь и логику по своему усмотрению.

Такой подход улучшает организацию кода: модель сама знает, как загрузить и сохранить себя, а вызывающий код (например, `ViewModel` или `Page`) просто вызывает эти методы. Да, перенос методов чтения и записи XML в модель `UserPreferences` — хорошая практика, которая упрощает работу с данными и соответствует рекомендациям по сериализации в C#.

## Данные
- [ ] Основные модели данных — автогенерации классов EF;
- [ ] Расширения моделей данных — частичные классы, реализующие расширения основных моделей данных.
- [ ] Дополнительные модели данных — реализующие недостающие модели, персистируемые локально.
- [ ] Модели представлений
- [ ] Вспомогательные модели ?

## Безопасность
Просмотр/предпросмотр сохраненного пароля приципиально невозможен вследствие используемой модели защиты (хэширование с применением соли), что обеспечивает дополнительную ступень защиты - даже при получении несанкционированного доступа к учетной записи третьи лица не смогут изменить пароль для предотвращения доступа санкционированному лицу.
