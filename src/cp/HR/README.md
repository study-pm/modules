Data-driven approach

Security

Test design

Многоязыковая поддержка

Описать структуру проекта, назначение каталогов

Концепции, архитектурные решения, шаблоны


/Media - любое содержимое этой папки игнорируется VCS
/Res (Resources)
/Static - статика это все что идет вместе с проектом. То есть css, js, изображения которые относятся к дизайну сайта, штифты и все что нужно для старта проекта с нуля. Содержимое всей этой папке будет игнорироваться VCS
/Static/Fonts
/Static/Icons
/Static/Images


Статика -- это код. Медиа -- это данные.

Если картинка -- это бекграунд, то это часть кода, часть поставки от программиста к заказчику. То есть тогда это static.

Если картинка -- это аватарка пользователя, которую загрузил пользователь твоего сайта, то тогда это media, ведь это пользовательские данные, а не часть кода. Сайт от программиста заказчику может быть поставлен без media, и заказчик своими силами/с помощью менеджеров/пользователей сам заполнит всю media так, как ему надо.

## Обоснование выбора инструментов
C#: типобезопаность, наилучшее соответствие целевой платформе (ОС Windows).

## Система безопасности
Двухфакторная аутентификация (по умолчанию отключена)
использование безопасных паролей, безопасных строк

По умолчанию пользователь активен (незаблокирован)

### Валидация

## Поддерживаемость, модульность, расширяемость

# Authentication / Аутентификация и безопасность

## Использование паролей
Генерация соли (salt) и хеширование пароля — это фундаментальные меры безопасности при хранении паролей, которые существенно усложняют задачу злоумышленнику, даже если он получил доступ к базе данных.

### Зачем нужны соль и хеш?
- Хеширование — это одностороннее преобразование пароля в фиксированное значение (хеш), которое невозможно или крайне трудно обратить обратно в исходный пароль. Это предотвращает раскрытие паролей в открытом виде при компрометации базы данных.

- Соль — это уникальное случайное значение, добавляемое к каждому паролю перед хешированием. Благодаря соли даже одинаковые пароли у разных пользователей будут иметь разные хеши, что предотвращает использование заранее подготовленных таблиц хешей (rainbow tables) и значительно усложняет атаку перебором.

### Почему это эффективно против злоумышленника?
- Если злоумышленник получит доступ к базе данных, он увидит только хеши с солью, а не сами пароли. Чтобы подобрать пароль, ему придется выполнять вычисления хешей для каждой возможной комбинации с учётом соли — это значительно увеличивает время и вычислительные ресурсы, необходимые для атаки.

- Современные алгоритмы хеширования (например, PBKDF2, bcrypt, Argon2) специально разработаны так, чтобы быть вычислительно затратными, что замедляет перебор паролей и делает атаку перебором практически невыгодной.

- Без соли злоумышленник может использовать готовые базы хешей популярных паролей (rainbow tables), что значительно ускоряет взлом. С солью такие таблицы бесполезны, так как для каждого пользователя нужен уникальный хеш с уникальной солью.

### Итог
- Хеширование с солью не делает пароль абсолютно неуязвимым, но значительно повышает безопасность и снижает риск быстрого восстановления пароля злоумышленником.

- Без этих мер злоумышленник может легко использовать предвычисленные таблицы или перебор популярных паролей, что значительно упрощает взлом.

- Использование соли и современных алгоритмов хеширования — это стандарт индустрии для защиты паролей в базах данных.

Таким образом, смысл генерации соли и хеширования в том, чтобы сделать процесс взлома паролей максимально трудоёмким и затратным для злоумышленника, даже при полном доступе к базе данных.

## Двухфакторная/двухэтапная аутентификация
Двухфакторная (2FA) и двухэтапная (2SV) аутентификации — это способы дополнительной защиты аккаунта. Часто между ними ставят знак равенства даже разработчики. Но это неверно.

### Двухфакторная аутентификация
Ключевое слово здесь — фактор. Всего их выделяют четыре:

- знание чего-либо — например, логина, пароля, ключа, кодовой фразы, любой другой секретной информации, которая задаётся при создании профиля;
- обладание чем-либо — например, аппаратным токеном или смартфоном с приложением, генерирующим коды;
- нахождение в конкретном месте — для определения используется, например, IP-адрес пользователя или радио-метка;
- обладание некими биологическими особенностями — например, сканирование отпечатка пальца или радужной оболочки глаза.

Двухфакторная аутентификация — это когда последовательно используются два фактора.

Например, есть аккаунт на Яндексе, в настройках которого включена двухфакторная аутентификация. Чтобы зайти в него на новом устройстве, требуется соблюдение двух факторов:

1. Я знаю логин.
2. Я обладаю смартфоном с приложением Яндекс.Ключ, которое генерирует коды для авторизации.

Есть и другие приложения для генерирования кодов: Google Authenticator, Microsoft Authenticator, LastPass Authenticator. Но все они решают одну задачу — выступают в качестве второго фактора при авторизации пользователя.

Вместо смартфона с приложением можно использовать аппаратный токен. Он подключается через порт USB, Bluetooth или NFC. Когда вы регистрируетесь на очередном сервисе и включаете двухфакторную аутентификацию, внутри токена генерируется новая пара ключей. Открытый ключ передаётся на сервер, закрытый — хранится на аппаратном токене.

Для двухфакторной аутентификации с помощью токенов [используется протокол FIDO U2F](https://tproger.ru/articles/fido-u2f). На сайте USB-Dongle Authentication можно [посмотреть список сервисов](https://www.dongleauth.info/), которые его поддерживают. Среди них, например, мессенджеры WhatsApp, Viber, Slack и Telegram.

Процесс авторизации с помощью аппаратного токена выглядит следующим образом:

1. Подключение к устройству аппаратного токена.
2. Ввод логина и пароля на сервисе.
3. Нажатие на физическую кнопку на токене или другое действие для 4. подтверждения присутствия пользователя за компьютером.
4. Сверка открытого и закрытого ключей.
5. Успешная авторизация в случае совместимости ключей.

Протокол FIDO U2F поддерживают браузеры Google Chrome, Mozilla Firefox, Microsoft Edge, Opera. На Safari поддержки по умолчанию нет, но её можно добавить с помощью расширения, [доступного для скачивания на GitHub](https://github.com/Safari-FIDO-U2F/Safari-FIDO-U2F).

Со сканированием отпечатков пальцев, радужной оболочки глаза, определением местоположения похожая ситуация. Чтобы второй фактор работал, нужна поддержка со стороны сервисов и устройств, через который пользователь пытается авторизоваться.

### Двухэтапная аутентификация?
С двухэтапной аутентификацией дело обстоит намного проще. Допустим, вы вводите пароль и получаете код подтверждения через SMS. Это два этапа, но один фактор — знание.

Например, двухэтапная аутентификация используется в Telegram. При авторизации на новом устройстве вы получаете код подтверждения в чате (если у вас есть доступ к аккаунту на другом устройстве) или через SMS. Это первый этап. После включения в настройках безопасности двухэтапной аутентификации появится ещё один шаг — ввод пароля, который вы сами придумали. Снова два шага, но один фактор — знание.

### 2FA vs. 2SA
В теме определения типа аутентификации находится место спорам. Например, есть мнение, что подтверждение личности через код в SMS — это фактор владения SIM-картой, на которую приходит сообщение. Поэтому стоит говорить об этой технологии аутентификации как о двухфакторной, пусть и крайне слабой, потому что SIM-карту можно без проблем перевыпустить, а номер телефона — подменить.

Скорее всего, корни этих разногласий уходят во времена, когда отправку кода через SMS действительно считали вторым фактором проверки. Однако эта практика остаётся в прошлом. Американский Национальный институт стандартов и технологий ещё в 2016 году [не рекомендовал использовать SMS в 2FA](https://techcrunch.com/2016/07/25/nist-declares-the-age-of-sms-based-2-factor-authentication-over/) из-за высокого риска взлома. В качестве альтернативы предложены приложения-генераторы кодов и аппаратные токены.

Тем не менее, некоторые сервисы продолжают называть SMS вторым фактором. Например, GitHub предлагает два способа использования двухфакторной аутентификации: генерирование ключа в приложении и отправку кода в сообщении. Обратная ситуация — Google называет все способы дополнительной защиты двухэтапной аутентификацией, хотя среди них есть использование аппаратного токена и генерирование кодов в приложении.

Впрочем, эти разногласия возникают только в спорах людей, интересующихся информационной безопасностью. Разработчикам достаточно помнить, что подтверждение личности через SMS — это слабая защита, и по возможности добавлять поддержку более сильных факторов. Простым же пользователям чётко представлять разницу между двухэтапной и двухфакторной аутентификациями не обязательно.[^chem-dvuhfaktornaja-autentifikacija-otlichaetsja-ot-dvuhjetapnoj]

[^chem-dvuhfaktornaja-autentifikacija-otlichaetsja-ot-dvuhjetapnoj]: [Чем двухфакторная аутентификация отличается от двухэтапной?](https://tproger.ru/articles/chem-dvuhfaktornaja-autentifikacija-otlichaetsja-ot-dvuhjetapnoj)

### Хранение секрета
Хранить пользовательский секрет (shared secret) для TOTP в базе данных можно, но при этом необходимо обеспечить его защиту, так как компрометация этого ключа полностью нивелирует безопасность двухфакторной аутентификации.

Риски и рекомендации по безопасному хранению секрета TOTP:
- Секрет — это ключ к генерации одноразовых кодов, и если злоумышленник получит к нему доступ, он сможет генерировать действительные коды 2FA и обходить защиту.

- Не следует хранить секрет в открытом виде. Необходимо использовать шифрование секрета при сохранении в базе данных. Например, можно применять симметричное шифрование с ключом, который хранится отдельно от базы данных, или использовать аппаратные модули безопасности (HSM).

- Необходимо ограничить доступ к базе данных и использовать средства контроля доступа и аудита, чтобы снизить риск утечки данных.

- Не следует встраивать секрет напрямую в QR-код, который передаётся пользователю, лучше использовать временные токены или ссылки, запускающие процесс настройки 2FA.

- Можно рассмотреть возможность использования аппаратных ключей безопасности (например, YubiKey), которые хранят секреты в защищённом виде, что повышает безопасность по сравнению с хранением секрета в базе.

- Рекомендуется обеспечить возможность восстановления доступа на случай потери устройства, например, через резервные коды, чтобы избежать блокировки пользователя.

Хранение пользовательского секрета TOTP в базе данных без должной защиты небезопасно и может привести к компрометации 2FA. Однако при использовании шифрования, строгого контроля доступа и других мер безопасности это вполне приемлемая практика для большинства приложений.

Таким образом, секреты TOTP можно хранить в базе, но только с применением надежных методов защиты, чтобы предотвратить их утечку и сохранить эффективность двухфакторной аутентификации.

Следует также иметь в виду, что хранить секрет (Secret) для двухфакторной аутентификации в базе данных как хеш с солью (SecretHash и SecretSalt), как это делают с паролями, не рекомендуется. Причина в том, что для проверки одноразовых кодов TOTP необходимо иметь исходный секрет в открытом виде, чтобы генерировать коды на сервере и сверять их с кодами пользователя.

Как правильно хранить Secret для 2FA
- Секрет должен храниться в базе в зашифрованном виде, а не в виде хеша, потому что хеширование — односторонняя операция, и вы не сможете восстановить секрет для генерации кодов.

- Необходимо использовать симметричное шифрование (например, AES) с надёжным ключом, который хранится отдельно (например, в защищённом хранилище ключей, аппаратном модуле безопасности или в сервисах управления ключами).

- Требуется обеспечить строгий контроль доступа к базе данных и ключам шифрования.

- При необходимости следует расшифровывать секрет только в памяти приложения, а не хранить его в открытом виде на диске или в базе.

Почему не стоит использовать хеширование (SecretHash + SecretSalt):
- Хеширование подходит для паролей, когда нужно проверить, совпадает ли введённый пароль с сохранённым хешем, без возможности восстановить исходный пароль.

- Для TOTP-секрета нужно именно восстановить исходное значение, чтобы генерировать коды, поэтому хеширование не подходит.

| Подход                   | Можно ли использовать для хранения TOTP-секрета? | Комментарии                                          |
| ------------------------ | ------------------------------------------------ | ---------------------------------------------------- |
| Хеш + соль               | Нет                                              | Нельзя восстановить исходный секрет                  |
| Шифрование (AES и др.)   | Да                                               | Позволяет безопасно хранить и восстанавливать секрет |
| Хранение в открытом виде | Нет                                              | Уязвимо для утечки и компрометации                   |

Таким образом, секрет для 2FA нужно хранить в базе в зашифрованном виде, а не в виде хеша с солью. Это обеспечивает баланс между безопасностью и функциональностью проверки одноразовых кодов. Для повышения безопасности используйте надёжное шифрование и управление ключами согласно лучшим практикам защиты баз данных.

### Документация
Наиболее отвественные фрагменты кода сопровождены комментариями, все ключевые методы задокументированы XML-комментариями.

## Пользователи и роли
Изначально приложение поставляется со встроенной пользовательской записью `root`, обладающей правами администратора. Это единственная пользовательская запись (аккаунт), не прикрепленная к какому-либо сотруднику.
- `maintainer`: может добавлять и редактировать любые записи, кроме относящихся непосредственно к управлению пользователями (сброс пароля, блокировка/разблокировка, работа с журналом пользователей и т.п.)
- `editor`: может редактировать любые записи, кроме относящихся непосредственно к управлению пользователями (сброс пароля, блокировка/разблокировка, работа с журналом пользователей и т.п.)
- `user`: может просматривать любую информацию, кроме относящихся непосредственно к управлению пользователями (сброс пароля, блокировка/разблокировка, работа с журналом пользователей и т.п.)

Для сокращения количества малозначащих таблиц в БД (для названий статусов и т.п.) в программном коде предусмотрены расширения сгенерированных EF классов. Эти частичные классы дополняют базовый функционал модели различными производными надстройками (`UserStatus`, `Experience` и т.п.).

## Staff
Разные изображения-заглушки в зависимости от пола.

Асинхронная валидация для оптимизации производительности реализована с отлагаемой задержкой выполнения (Wait debounce delay). Таким образом, при частом изменении значений в поле запросы в БД будут выполняться только 

## Данные
обеспечение целостности, непротиворечивости данных. Многоуровневая система:
- валидация на входе
- проверка данных

## XML vs. CSV
Выбор XML продиктован наличием встроенных средств WPF.
