# МДК 01.01 Разработка программных модулей
[671399405040133e8429e521](https://e-learn.petrocollege.ru/course/view.php?id=6620)

- [Общее](#общее)
  - [Разбор заданий №2](#разбор-заданий-2)
  - [Разбор демоэкзамена](#разбор-демоэкзамена)
    - [Навыки и умения](#навыки-и-умения)
    - [Техника безопасности](#техника-безопасности)
    - [Рабочее место](#рабочее-место)
    - [Задание](#задание)
    - [Модуль 4](#модуль-4)
    - [Модуль 6](#модуль-6)
- [53-02в 53-03в / Прикладное программирование: технологии C#.Net](#53-02в-53-03в--прикладное-программирование-технологии-cnet)
  - [Лекция Введение в технологию](#лекция-введение-в-технологию)
    - [Особенности платформы WPF (Windows Presentation Foundation)](#особенности-платформы-wpf-windows-presentation-foundation)
      - [Преимущества WPF](#преимущества-wpf)
      - [Архитектура WPF](#архитектура-wpf)
      - [Задание. Калькулятор](#задание-калькулятор)
        - [Структура проекта](#структура-проекта)
        - [Создание калькулятора](#создание-калькулятора)
  - [Лекция Базовые элементы](#лекция-базовые-элементы)
    - [Элементы управления](#элементы-управления)
      - [Обзор элементов управления и их свойств](#обзор-элементов-управления-и-их-свойств)
        - [`System.Threading.DispatcherObject`](#systemthreadingdispatcherobject)
        - [`System.Windows.DependencyObject`](#systemwindowsdependencyobject)
        - [`System.Windows.Media.Visual`](#systemwindowsmediavisual)
        - [`System.Windows.UIElement`](#systemwindowsuielement)
        - [`System.Windows.FrameworkElement`](#systemwindowsframeworkelement)
        - [`System.Windows.Controls.Control`](#systemwindowscontrolscontrol)
        - [`Name`](#name)
        - [`FieldModifier`](#fieldmodifier)
        - [`Visibility`](#visibility)
        - [Свойства настройки шрифтов](#свойства-настройки-шрифтов)
        - [`Cursor`](#cursor)
        - [`FlowDirection`](#flowdirection)
        - [Цвета фона и шрифта](#цвета-фона-и-шрифта)
  - [Основы LINQ](#основы-linq)
    - [Методы расширения LINQ](#методы-расширения-linq)
    - [Лямбда-выражения](#лямбда-выражения)
    - [LINQ: Фильтрация where](#linq-фильтрация-where)
    - [LINQ: Сложные фильтры where](#linq-сложные-фильтры-where)
    - [LINQ: проекция select](#linq-проекция-select)
    - [LINQ: переменные и `let`](#linq-переменные-и-let)
    - [LINQ: выборка из нескольких источников](#linq-выборка-из-нескольких-источников)
    - [LINQ: сортировка orderby](#linq-сортировка-orderby)
    - [LINQ: сортировка сложных объектов](#linq-сортировка-сложных-объектов)
    - [LINQ: множественные критерии сортировки](#linq-множественные-критерии-сортировки)
  - [Лекция Подключение БД](#лекция-подключение-бд)
    - [Строка подключения для MS SQL Server](#строка-подключения-для-ms-sql-server)
    - [Получение информации о подключении](#получение-информации-о-подключении)
  - [Пример подключения](#пример-подключения)
  - [Работа с бд](#работа-с-бд)
    - [Руководство по стилю](#руководство-по-стилю)
      - [Общие требования](#общие-требования)
      - [Использование логотипа](#использование-логотипа)
      - [Шрифт](#шрифт)
      - [Цветовая схема](#цветовая-схема)
    - [Ресурсы](#ресурсы)
      - [Данные](#данные)
  - [Авторизация WPF / Реализация авторизации и регистрации пользователя в WPF-приложении (C#) к базе данных MS SQL Server](#авторизация-wpf--реализация-авторизации-и-регистрации-пользователя-в-wpf-приложении-c-к-базе-данных-ms-sql-server)
    - [Создание базы данных и подключение ее к проекту](#создание-базы-данных-и-подключение-ее-к-проекту)
      - [Создание БД](#создание-бд)
      - [Создание модели БД](#создание-модели-бд)
      - [Подключение к БД](#подключение-к-бд)
      - [Интерфейс приложения (главное окно)](#интерфейс-приложения-главное-окно)
      - [Добавление страниц](#добавление-страниц)
        - [Страница авторизации](#страница-авторизации)
      - [Функционал авторизации](#функционал-авторизации)
  - [Задание на авторизацию и создание бд](#задание-на-авторизацию-и-создание-бд)
  - [Регистрация WPF](#регистрация-wpf)
    - [Реализация регистрации пользователя в WPF-приложении (C#) к базе данных MS SQL Server (практическая работа)](#реализация-регистрации-пользователя-в-wpf-приложении-c-к-базе-данных-ms-sql-server-практическая-работа)
      - [Страница регистрации](#страница-регистрации)
      - [Функционал прохождения регистрации ученика](#функционал-прохождения-регистрации-ученика)
  - [Задание Регистрация WPF](#задание-регистрация-wpf)
  - [Данные](#данные-1)
  - [Вывод данных](#вывод-данных)
  - [Фильтрация, поиск, сортировка](#фильтрация-поиск-сортировка)
  - [Формирование qr кода](#формирование-qr-кода)
  - [Формирование pdf документа](#формирование-pdf-документа)
  - [Добавление, редактирование, удаление](#добавление-редактирование-удаление)
    - [Реализация функции добавления](#реализация-функции-добавления)
    - [Реализация функции редактирования](#реализация-функции-редактирования)
    - [Реализация функции удаления](#реализация-функции-удаления)
  - [Практическая работа "Диспетчеры компоновки"](#практическая-работа-диспетчеры-компоновки)
    - [Диспетчер компоновки Canvas](#диспетчер-компоновки-canvas)
      - [Присоединяемые свойства XAML (attached properties)](#присоединяемые-свойства-xaml-attached-properties)
        - [Определение присоединенного свойства](#определение-присоединенного-свойства)
        - [Использование в XAML](#использование-в-xaml)
        - [Пример](#пример)
    - [Диспетчер компоновки WrapPanel](#диспетчер-компоновки-wrappanel)
    - [Диспетчер компоновки StackPanel](#диспетчер-компоновки-stackpanel)
    - [Диспетчер компоновки DockPanel](#диспетчер-компоновки-dockpanel)
    - [Диспетчер компоновки Grid](#диспетчер-компоновки-grid)
    - [Задание](#задание-1)
    - [Дополнительное задание](#дополнительное-задание)
  - [Практическая работа "Основные элементы управления WPF"](#практическая-работа-основные-элементы-управления-wpf)
    - [Элемент управления Button (кнопка)](#элемент-управления-button-кнопка)
    - [Элемент управления ToggleButton (переключаемая кнопка)](#элемент-управления-togglebutton-переключаемая-кнопка)
    - [Элемент управления CheckBox (независимый переключатель)](#элемент-управления-checkbox-независимый-переключатель)
    - [Элемент управления RadioButton (зависимый переключатель)](#элемент-управления-radiobutton-зависимый-переключатель)
    - [Элемент управления ComboBox (выпадающий список)](#элемент-управления-combobox-выпадающий-список)
    - [Элемент управления ListBox (список)](#элемент-управления-listbox-список)
    - [Элемент управления Slider](#элемент-управления-slider)
    - [Меню](#меню)
    - [Панель инструментов](#панель-инструментов)
    - [Строка состояния](#строка-состояния)
    - [Элемент управления InkCanvas](#элемент-управления-inkcanvas)
    - [Обработчики событий](#обработчики-событий)
    - [Задание 1](#задание-1)
    - [Задание 2](#задание-2)
  - [Практическая работа Привязка данных](#практическая-работа-привязка-данных)
    - [Задание 1](#задание-1-1)
    - [Режимы привязки](#режимы-привязки)
    - [Задание 2](#задание-2-1)
    - [Задание 3](#задание-3)
    - [Задание 4](#задание-4)
  - [Практическая работа Стили WPF](#практическая-работа-стили-wpf)
    - [Задание 1](#задание-1-2)
    - [Задание 2](#задание-2-2)
    - [Задание 3](#задание-3-1)
  - [ПР04-4 LINQ в Entity Framework. Поиск и фильтрация](#пр04-4-linq-в-entity-framework-поиск-и-фильтрация)
- [КП](#кп)
  - [Курсовое проектирование](#курсовое-проектирование)
  - [Темы работ](#темы-работ)
  - [Задание 1. Результат проектирования структуры классов и БД](#задание-1-результат-проектирования-структуры-классов-и-бд)
  - [Задание 2. Результат разработки форм авторизации, главной формы и форм-меню](#задание-2-результат-разработки-форм-авторизации-главной-формы-и-форм-меню)
  - [Задание 3. Результат разработки приложения](#задание-3-результат-разработки-приложения)
  - [Задание 4. Итоговое приложение](#задание-4-итоговое-приложение)
  - [Задание 5. Курсовой проект (пояснительная записка + презентация)](#задание-5-курсовой-проект-пояснительная-записка--презентация)
  - [Задание для КП](#задание-для-кп)
  - [Примерное ТЗ и описание предметной области](#примерное-тз-и-описание-предметной-области)
    - [Описание предметной области](#описание-предметной-области)
    - [Техническое задание](#техническое-задание)

## Общее
[6720ad8d5040133e8429e595](https://e-learn.petrocollege.ru/course/view.php?id=6620#section-0)

### Разбор заданий №2
[67ae05215040133e8429ef14](https://e-learn.petrocollege.ru/mod/url/view.php?id=303215)

Нажмите на ссылку https://nationalteam.worldskills.ru/skills/programmnye-resheniya-dlya-biznesa/, чтобы открыть ресурс.

### Разбор демоэкзамена
[67b093b35040133e8429ef42](https://e-learn.petrocollege.ru/mod/url/view.php?id=303214)

- [ ] [Демонстрационный экзамен. Компетенция "Программные решения для бизнеса"](https://www.youtube.com/watch?v=CLfYbXGrC44)

#### Навыки и умения
Спецификация стандартов Worldskills (WSS):
1. Организация и управление работой.
2. Компетенции общения и межличностных отношений.
3. Решение проблем, инновации, креативность.
4. Анализ и проектирование программных решений.
5. Разработка программных решений.
6. Тестирование программных решений.

#### Техника безопасности
Физические источники потенциальной опасности:
- повышенный уровень электромагнитного излучения;
- повышенный уровень статического электричества;
- повышенная яркость и уровень пульсации светового потока;
- напряжение в электрической цепи;
- повышенный или недостаточный уровень освещенности.

Психофизиологические источники потенциальной опасности
- напряжение зрения и внимания;
- интеллектуальные и эмоциональные нагрузки;
- длительные статические нагрузки;
- монотонность труда.

Необходимо выполнять технологический перерыв 15 минут каждый 1,5 часа работы.

#### Рабочее место
Программное обеспечение:
1. Visual Studio 2019
2. Netbeans
3. SQL Management studio 2019
4. MySQL Workbench 8.0 CE
5. Microsoft Office или аналог
6. Microsoft Visio (для UML)

#### Задание
Этапы:
1. **Модуль 4**: разработка базы данных и ее импорт.
   - реализация базы данных в выбранной СУБД, создание таблиц, связей, полей в таблицах на основании ERD или при помощи скрипта, приведение исходных файлов к виду, подходящему для импорта, импорт исходных данных разного формата.
2. **Модуль 6**: разработка
   - создание настольного приложения, различных окон, таблиц, списков, форм для заполнения и работы с базой данных, разработка библиотек классов.
3. **Модуль 11**: общий профессионализм решения
   - возможность развития информационной системы другими разработчиками, соответствие руководству по стилю заказчика, обратная связь системы с пользователем, стабильная работа всех разработанных программ, стиль кода на протяжении разработки всей информационной системы должен требовать пожеланиям заказчика, организация файловой структуры проекта, соблюдение культуры кодирования и комменатрии по коду.

#### Модуль 4
1. Подготовка данных для импорта из предлагаемого скрипта.
2. Импорт данных из файла.

#### Модуль 6
1. Выбор технологии, платформы и среды для реализации информационной системы.

## 53-02в 53-03в / Прикладное программирование: технологии C#.Net
[6720ae035040133e8429e596](https://e-learn.petrocollege.ru/course/view.php?id=6620#section-2)

### Лекция Введение в технологию
[67b2fa0d5040133e8429ef5d](https://e-learn.petrocollege.ru/mod/resource/view.php?id=369408)

#### Особенности платформы WPF (Windows Presentation Foundation)

*[WPF]: Windows Presentation Foundation
Технология **WPF** (**Windows Presentation Foundation**) является часть экосистемы платформы .NET и представляет собой подсистему для построения графических интерфейсов.

Если при создании традиционных приложений на основе WinForms за отрисовку элементов управления и графики отвечали такие части ОС Windows, как User32 и GDI+, то приложения WPF основаны на **DirectX**. В этом состоит ключевая особенность рендеринга графики в WPF: используя WPF, значительная часть работы по отрисовке графики, как простейших кнопочек, так и сложных 3D-моделей, ложится на графический процессор на видеокарте, что также позволяет воспользоваться аппаратным ускорением графики.

Одной из важных особенностей является использование языка декларативной разметки интерфейса XAML, основанного на XML: вы можете создавать насыщенный графический интерфейс, используя или декларативное объявление интерфейса, или код на управляемых языках C# и VB.NET, либо совмещать и то, и другое.

##### Преимущества WPF
Что вам, как разработчику, предлагает WPF?
- Использование традиционных языков .NET-платформы — C# и VB.NET для создания логики приложения.
- Возможность **декларативного определения** графического интерфейса с помощью специального языка разметки XAML, основанном на xml и представляющем альтернативу программному созданию графики и элементов управления, а также возможность комбинировать XAML и C#/VB.NET.
- **Независимость от разрешения экрана**: поскольку в WPF все элементы измеряются в независимых от устройства единицах, приложения на WPF легко масштабируются под разные экраны с разным разрешением.
- Новые возможности, которых сложно было достичь в WinForms, например, создание трехмерных моделей, привязка данных, использование таких элементов, как стили, шаблоны, темы и др.
- Хорошее **взаимодействие с WinForms**, благодаря чему, например, в приложениях WPF можно использовать традиционные элементы управления из WinForms.
- **Богатые возможности** по созданию различных приложений: это и  мультимедиа, и двухмерная и трехмерная графика, и богатый  набор встроенных элементов управления, а также возможность самим создавать новые элементы, создание анимаций, привязка данных, стили, шаблоны, темы и многое другое.
- **Аппаратное ускорение графики** — вне зависимости от того, работаете ли вы с 2D или 3D, графикой или текстом, все компоненты приложения транслируются в объекты, понятные Direct3D, и затем визуализируются с помощью процессора на видеокарте, что повышает производительность, делает графику более плавной.
- Создание приложений под множество ОС семейства Windows — от Windows XP до Windows 10.

В тоже время WPF имеет определенные **ограничения**. Несмотря на поддержку трехмерной визуализации, для создания приложений с большим количеством трехмерных изображений, прежде всего игр, лучше использовать другие средства — DirectX или специальные фреймворки, такие как Monogame или Unity.

Также стоит учитывать, что по сравнению с приложениями на Windows Forms объем программ на WPF и потребление ими памяти в процессе работы в среднем несколько выше. Но это с лихвой компенсируется более широкими графическими возможностями и повышенной производительностью при отрисовке графики.

##### Архитектура WPF
Схематически архитектуру WPF можно представить следующим образом:

![WPF Architecture](./img/wpf-architecture.png)

Как видно на схеме, WPF разбивается на два уровня: managed API и unmanaged API (уровень интеграции с DirectX).

<dfn title="managed API">Managed API</dfn> (<dfn title="управляемый API-интерфейс">управляемый API-интерфейс</dfn>) содержит код, исполняемый под управлением общеязыковой среды выполнения .NET — Common Language Runtime. Этот API описывает основной функционал платформы WPF и состоит из следующих компонентов:

- **PresentationFramework.dll**: содержит все основные реализации компонентов и элементов управления, которые используются при построении графического интерфейса.
- **PresentationCore.dll**: содержит все базовые типы для большинства классов из PresentationFramework.dll.
- **WindowsBase.dll**: содержит ряд вспомогательных классов, которые применяются в WPF, но могут также использоваться и вне данной платформы

<dfn title="unmanaged API">Unmanaged API</dfn> используется для интеграции вышележащего уровня с DirectX:
- **milcore.dll**: собственно обеспечивает интеграцию компонентов WPF с DirectX. Данный компонент написан на неуправляемом коде (С/С++) для взаимодействия с DirectX.
- **WindowsCodecs.dll**: библиотека, которая предоставляет низкоуровневую поддержку для изображений в WPF.

Еще ниже собственно находятся компоненты операционной системы и DirectX, которые производят визуализацию компонентов приложения, либо выполняют прочую низкоуровневую обработку. В частности, с помощью низкоуровневого интерфейса Direct3D, который входит в состав DirectX, происходит трансляция изображения на экран.

Здесь также на одном уровне находится библиотека **user32.dll**. И хотя выше говорилось, что WPF не использует эту библиотеку для рендеринга и визуализации, однако для ряда вычислительных задач (не включающих визуализацию) данная библиотека может быть задействована.

##### Задание. Калькулятор
В Visual Studio в меню *File* (Файл) выберем пункт *New* (*Создать*) -> *Project...* (*Проект...*). Перед нами откроется диалоговое окно создания проекта, в котором мы 
выберем шаблон WPF Application:

- Укажем проекту какое-нибудь имя и нажмем кнопку OK. И Visual Studio создаст нам новый проект.

По умолчанию студия открывает создает и открывает нам два файла: файл декларативной разметки интерфейса *MainWindow.xaml* и файл связанного с разметкой кода *MainWindow.xaml.cs*. Файл *MainWindow.xaml* имеет два представления: визуальное — в режиме WYSIWIG отображает весь графический интерфейс данного окна приложения, и под ним декларативное объявление интерфейса в XAML. Если мы изменим декларативную разметку, например, определим там кнопку, то эти изменения отображаться в визуальном представлении.

###### Структура проекта
В структуре проекта WPF следует выделить следующие моменты. Во-первых, в проекте имеется файл *App.xaml* и связанный с ним файл кода *App.xaml.cs* — это глобальные файлы для всего приложения, позже мы о них поговорим подробнее. А пока только следует знать, что *App.xaml* задает файл окна программы, которое будет открываться при запуске приложения. Если вы откроете этот файл, то можете найти в нем строку `StartupUri="MainWindow.xaml"` — то есть в данном случае, когда мы запустим приложение, будет создаваться интерфейс из файла *MainWindow.xaml*.

Далее в структуре определены файл разметки *MainWindow.xaml* и файл связанного кода *MainWindow.xaml.cs*. Файл *MainWindow.xaml* и представляет определение окна приложение, которое мы увидим при запуске.

###### Создание калькулятора
Теперь создадим первое приложение. Перейдем к файлу ***MainWindow.xaml***. Сейчас его разметка XAML, созданная по умолчанию, представляет следующее:
```xml
<Window x:Class="FirstWpfApp.MainWindow"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  xmlns:local="clr-namespace:FirstWpfApp"
  mc:Ignorable="d"
  Title="MainWindow" Height="350" Width="525">
  <Grid>
  </Grid>
</Window>
```

XAML в целом напоминает язык разметки HTML: здесь у нас сначала определен элемент верхнего уровня `Window` — окно приложения, в нем определен элемент `Grid`  — контейнер верхнего уровня, в который мы можем добавлять другие элементы. Каждый элемент может иметь  определенные атрибуты. Более подробно с языком XAML и элементами мы познакомимся позднее, а пока изменим эту разметку на следующую:
```xml
<Window x:Class="FirstWpfApp.MainWindow"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  Title="Калькулятор" Height="250" Width="300">
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid.RowDefinitions>
      <RowDefinition />
      <RowDefinition />
      <RowDefinition />
      <RowDefinition />
      <RowDefinition />
    </Grid.RowDefinitions>
    <Grid.ColumnDefinitions>
      <ColumnDefinition />
      <ColumnDefinition />
      <ColumnDefinition />
      <ColumnDefinition />
    </Grid.ColumnDefinitions>
    <TextBlock x:Name="textBlock" Grid.Column="0"
    Grid.ColumnSpan="4" />
    <Button Grid.Column="0" Grid.Row="1">1</Button>
    <Button Grid.Column="1" Grid.Row="1">2</Button>
    <Button Grid.Column="2" Grid.Row="1">3</Button>
    <Button Grid.Column="3" Grid.Row="1">4</Button>
    <Button Grid.Column="0" Grid.Row="2">5</Button>
    <Button Grid.Column="1" Grid.Row="2">6</Button>
    <Button Grid.Column="2" Grid.Row="2">7</Button>
    <Button Grid.Column="3" Grid.Row="2">8</Button>
    <Button Grid.Column="0" Grid.Row="3">9</Button>
    <Button Grid.Column="1" Grid.Row="3">0</Button>
    <Button Grid.Column="2" Grid.Row="3">+</Button>
    <Button Grid.Column="3" Grid.Row="3">-</Button>
    <Button Grid.Column="0" Grid.Row="4">*</Button>
    <Button Grid.Column="1" Grid.Row="4">/</Button>
    <Button Grid.Column="2" Grid.Row="4">=</Button>
    <Button Grid.Column="3" Grid.Row="4">CLEAR</Button>
  </Grid>
</Window>
```

Здесь мы задали массив кнопок как в обычном калькуляторе. После изменения разметки, визуальное представление интерфейса также изменится, и вы сможете там разглядеть подобие калькулятора. Теперь откроем файл логики, привязанной к данной разметке, ***MainWindow.xaml.cs***. Сейчас он имеет следующий код:
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace FirstWpfApp
{
  public partial class MainWindow : Window
  {
    public MainWindow()
    {
      InitializeComponent();
    }
  }
}
```

И изменим его на следующий:
```cs
using System;
using System.Windows;
using System.Windows.Controls;

namespace FirstWpfApp
{
  public partial class MainWindow : Window
  {
    string leftop = ""; // Левый операнд
    string operation = ""; // Знак операции
    string rightop = ""; // Правый операнд

    public MainWindow()
    {
      InitializeComponent();
      // Добавляем обработчик для всех кнопок на гриде
      foreach (UIElement c in LayoutRoot.Children)
      {
        if (c is Button)
        {
          ((Button)c).Click += Button_Click;
        }
      }
    }
    private void Button_Click(object sender, RoutedEventArgs e)
    {
      // Получаем текст кнопки
      string s = (string)((Button)e.OriginalSource).Content;
      // Добавляем его в текстовое поле
      textBlock.Text += s;
      int num;
      // Пытаемся преобразовать его в число
      bool result = Int32.TryParse(s, out num);
      // Если текст - это число
      if (result == true)
      {
        // Если операция не задана
        if (operation == "")
        {
          // Добавляем к левому операнду
          leftop += s;
        }
        else
        {
          // Иначе к правому операнду
          rightop += s;
        }
      }
      // Если было введено не число
      else
      {
        // Если равно, то выводим результат операции
        if (s == "=")
        {
          Update_RightOp();
          textBlock.Text += rightop;
          operation = "";
        }
        // Очищаем поле и переменные
        else if (s == "CLEAR")
        {
          leftop = "";
          rightop = "";
          operation = "";
          textBlock.Text = "";
        }
        // Получаем операцию
        else
        {
          // Если правый операнд уже имеется, то присваиваем его значение левому
          // операнду, а правый операнд очищаем
          if (rightop != "")
          {
            Update_RightOp();
            leftop = rightop;
            rightop = "";
          }
          operation = s;
        }
      }
    }
    // Обновляем значение правого операнда
    private void Update_RightOp()
    {
      int num1 = Int32.Parse(leftop);
      int num2 = Int32.Parse(rightop);
      // И выполняем операцию
      switch (operation)
      {
        case "+":
          rightop = (num1 + num2).ToString();
          break;
        case "-":
          rightop = (num1 - num2).ToString();
          break;
        case "*":
          rightop = (num1 * num2).ToString();
          break;
        case "/":
          rightop = (num1 / num2).ToString();
          break;
      }
    }
  }
}
```

Большая часть кода использует обычные выражения языка C#, за исключением отдельных моментов. Для большего понимания написаны комментарии. И теперь можете запустить приложение:

- _**Доработать приложение. Добавить функции остатка от деления, целочисленного деления, проверку на корректность.**_

Отправить полученный калькулятор в личном кабинете. Работайте самостоятельно, одинаковые программы не посылать!

### Лекция Базовые элементы
[67b444d75040133e8429ef7d](https://e-learn.petrocollege.ru/mod/resource/view.php?id=369409)

#### Элементы управления

##### Обзор элементов управления и их свойств
Чтобы как-то взаимодействовать с пользователем, получать от пользователя ввод с клавиатуры или мыши и использовать введенные данные в программе, нам нужны элементы управления. WPF предлагает нам богатый стандартный набор элементов управления.

Все элементы управления могут быть условно разделены на несколько подгрупп:
- Элементы управления содержимым, например кнопки (`Button`), метки (`Label`).
- Специальные контейнеры, которые содержат другие элементы, но в отличие от элементов `Grid` или `Canvas` не являются контейнерами компоновки — `ScrollViewer`, `GroupBox`.
- Декораторы, чье предназначение создание определенного фона вокруг вложенных элементов, например, `Border` или `Viewbox`.
- Элементы управления списками, например, `ListBox`, `ComboBox`.
- Текстовые элементы управления, например, `TextBox`, `RichTextBox`.
- Элементы, основанные на диапазонах значений, например, `ProgressBar`, `Slider`.
- Элементы для работ с датами, например, `DatePicker` и `Calendar`.
- Остальные элементы управления, которые не вошли в предыдущие подгруппы, например, `Image`.

Все элементы управления наследуются от общего класса `System.Window.Controls.Control` и имеют ряд общих свойств. А общую иерархию элементов управления можно
представить следующим образом:

![Elements hierarchy](./img/elements-hierarchy.png)

Вкратце рассмотрим, что представляют все эти типы в иерархии.

###### `System.Threading.DispatcherObject`
*[STA]: Single-Thread Affinity
В основе WPF лежит модель STA (Single-Thread Affinity), согласно которой за пользовательский интерфейс отвечает один поток. И чтобы пользовательский интерфейс мог взаимодействовать с другими потоками, WPF использует концепцию диспетчера — специального объекта, управляющего обменом сообщениями, через которые взаимодействуют потоки. Наследование типов от класса `DispatcherObject` позволяет получить доступ к подобному объекту-диспетчеру и и другим функциям по управлению параллелизмом.

###### `System.Windows.DependencyObject`
Наследование от этого класса позволяет взаимодействовать с элементами в приложении через их специальную модель свойств, которые называются свойствами зависимостей (dependency properties). Эта модель упрощает применение ряда особенностей WPF, например, привязки данных. Так, система свойств зависимостей отслеживает зависимости между значениями свойств, автоматически проверяет их и изменяет при изменении зависимости.

###### `System.Windows.Media.Visual`
Класс `Visual` содержит инструкции, которые отвечают за отрисовку, визуализацию объекта.

###### `System.Windows.UIElement`
Класс `UIElement` добавляет возможности по компоновке элемента, обработку событий и получение ввода.

###### `System.Windows.FrameworkElement`
Класс `FrameworkElement` добавляет поддержку привязки данных, анимации, стилей. Также добавляет ряд свойств, связанных с компоновкой (выравнивание, отступы) и ряд других.

###### `System.Windows.Controls.Control`
Класс `Control` представляет элемент управления, с которым взаимодействует пользователь. Этот класс добавляет ряд дополнительных свойств для поддержки элементами шрифтов, цветов фона, шрифта, а также добавляет поддержку шаблонов — специального механизма в WPF, который позволяет изменять стандартное представление элемента, кастомизировать его.

И далее от класса `Control` наследуются непосредственно конкретные элементы управления или их базовые классы, которые получают весь функционал, добавляемый к типам в этой
иерархии классов.

Рассмотрим некоторые из основных свойств, которые наследуются элементами управления.

###### `Name`
Наверное важнейшее свойство. По установленному имени впоследствии можно будет обращаться к элементу, как в коде, так и в xaml разметке. Например, в xaml-коде у нас определена следующая кнопка:
```xml
<Button x:Name="button1" Width="60" Height="30" Content="Текст"
Click="button1_Click" />
```

Здесь у нас задан атрибут `Click` с названием метода обработчика `button1_Click`, который будет определен в файле кода C# и будет вызываться по нажатию кнопки. Тогда в
связанном файле кода C# мы можем обратиться к этой кнопке:
```cs
private void button1_Click(object sender, RoutedEventArgs e)
{
 button1.Content = "Привет!";
}
```

Поскольку свойство `Name` имеет значение `button1`, то через это значение мы можем обратиться к кнопке в коде.

###### `FieldModifier`
Свойство `FieldModifier` задает модификатор доступа к объекту:
```xml
<StackPanel>
 <Button x:FieldModifier="private" x:Name="button1" Content="Hello World"
/>
 <Button x:FieldModifier="internal" x:Name="button2" Content="Hello WPF"
/>
</StackPanel>
```

В качестве значения используются стандартные модификатора доступа языка C#: `private`, `protected`, `internal`, `protected internal` и `public`. В данном случае объявление кнопок с
модификаторами будет равноценно следующему их определению в коде:
```cs
private Button button1;
internal Button button2;
```

Если для элемента не определен атрибут `x:FieldModifier`, то по умолчанию он равен "protected internal".

###### `Visibility`
Это свойство устанавливает параметры видимости элемента и может принимать одно из трех значений:
- `Visible` — элемент виден и участвует в компоновке.
- `Collapsed` — элемент не виден и не участвует в компоновке.
- `Hidden` — элемент не виден, но при этом участвует в компоновке.

Различия между `Collapsed` и `Hidden` можно продемонстрировать на примере:
```xml
<Grid>
 <Grid.ColumnDefinitions>
 <ColumnDefinition Width="*" />
 <ColumnDefinition Width="*" />
 </Grid.ColumnDefinitions>
  <StackPanel Grid.Column="0" Background="Lavender">
    <Button Visibility="Collapsed" Content="Панель Collapsed" />
    <Button Height="20" Content="Visible Button" />
  </StackPanel>
  <StackPanel Grid.Column="1" Background="LightGreen">
    <Button Visibility="Hidden" Content="Панель Hidden" />
    <Button Height="20" Content="Visible Button" />
  </StackPanel>
</Grid>
```

![Picture 1](./img/67b444d75040133e8429ef7d-1.png)

###### Свойства настройки шрифтов
- `FontFamily` — определяет семейство шрифта (например, Arial, Verdana и т.д.)
- `FontSize` — определяет высоту шрифта
- `FontStyle` — определяет наклон шрифта, принимает одно из трех значений — `Normal`, `Italic`, `Oblique`.
- `FontWeight` — определяет толщину шрифта и принимает ряд значений, как `Black`, `Bold` и др.
- `FontStretch` — определяет, как будет растягивать или сжимать текст, например, значение `Condensed` сжимает текст, а `Expanded` — растягивает.

Например:
```xml
<Button Content="Hello World!" FontFamily="Verdana" FontSize="13"
FontStretch="Expanded" />
```

###### `Cursor`
Это свойство позволяет нам получить или установить курсор для элемента управления в одно из значений, например, `Hand`, `Arrow`, `Wait` и др. Например, установка курсора в коде
c#: `button1.Cursor=Cursors.Hand;`

###### `FlowDirection`
Данное свойство задает направление текста. Если оно равно `RightToLeft`, то текст начинается с правого края, если — `LeftToRight`, то с левого.
```xml
<StackPanel>
 <TextBlock FlowDirection="RightToLeft">RightToLeft</TextBlock>
 <TextBlock FlowDirection="LeftToRight">LeftToRight</TextBlock>
</StackPanel>
```

![Picture 2](./img/67b444d75040133e8429ef7d-2.png)

###### Цвета фона и шрифта
Свойства `Background` и `Foreground` задают соответственно цвет фона и текста элемента управления.

Простейший способ задания цвета в коде xaml: `Background="#ffffff"`. В качестве значения свойство `Background` (`Foreground`) может принимать запись в виде шестнадцатеричного значения в формате `#rrggbb`, где `rr` — красная составляющая, `gg` — зеленая составляющая, а `bb` — синяя. Также можно задать цвет в формате `#aarrggbb`.

Либо можно использовать названия цветов напрямую:
```xml
<Button Width="60" Height="30" Background="LightGray" Foreground="DarkRed"
Content="Цвет" />
```

Однако при компиляции будет создаваться объект `SolidColorBrush`, который и будет задавать цвет элемента. То есть определение кнопки выше фактически будет равноценно следующему:
```xml
<Button Width="60" Height="30" Content="Цвет">
 <Button.Background>
 <SolidColorBrush Color="LightGray" />
 </Button.Background>
 <Button.Foreground>
 <SolidColorBrush Color="DarkRed" />
 </Button.Foreground>
</Button>
```

`SolidColorBrush` представляет собой кисть, покрывающую элемент одним цветом. Позже мы подробнее поговорим о цветах. А пока надо знать, что эти записи эквивалентны, кроме того, вторая форма определения цвета позволяет задать другие кисти — например, градиент.

Это надо также учитывать при установке или получении цвета элемента в коде c#:
```cs
button1.Background = new SolidColorBrush(Colors.Red);
button1.Foreground = new SolidColorBrush(Color.FromRgb(0,255, 0));
```

Класс `Colors` предлагает ряд встроенный цветовых констант, которыми мы можем воспользоваться. А если мы захотим конкретизировать настройки цвета с помощью значений RGB, то можно использовать метод `Color.FromRgb`.

### Основы LINQ
[6720af0b5040133e8429e597](https://e-learn.petrocollege.ru/mod/resource/view.php?id=302824)

*[LINQ]: Language-Integrated Query
<dfn title="LINQ">LINQ</dfn> (Language-Integrated Query) — технология Microsoft, предназначенная для поддержки запросов к данным всех типов на уровне языка.

Источник данных реализует интерфейс `IEnumerable` (коллекции, массивы, набор данных `DataSet`, документ XML и т.д.).

Вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.

Простейшее определение запроса LINQ:
```cs
from переменная in набор_объектов select переменная;
```

*Без LINQ*:
```cs
string[ ] teams = { "Бавария", "Боруссия", "Реал Мадрид", "Манчестер Сити", "ПСЖ", "Барселона" };

var selectedTeams = new List<string>( );
foreach(string s in teams)
{
    if (s.ToUpper( ).StartsWith("Б"))
        selectedTeasm.Add(s);
}
selectedTeams.Sort( );

foreach (string s in selectedTeams)
    Console.WriteLine(s);
```

*С LINQ*:
```cs
string[ ] teams = { "Бавария", "Боруссия", "Реал Мадрид", "Манчестер Сити", "ПСЖ", "Барселона" };

var selectedTeams = from t in teams // определяем каждый объект из teams как t
                    where t.ToUpper( ).StartsWith("Б") // фильтрация по критерию
                    orderby t // упорядочиваем по возрастанию
                    select t; // выбираем объект

foreach (string s in selectedTeams)
    Console.WriteLine(s);
```

*С лямбда-выражением и методом расширения*:
```cs
var selectedTeams = teams.Where(t => t.ToUpper( ).StartsWith("Б")).OrderBy(t => t);
```

[Code Example](./samples/01_LINQ/01_Basics/Program.cs)

#### Методы расширения LINQ
- **`Select`**: определяет проекцию выбранных значений

- **`Where`**: определяет фильтр выборки

- **`OrderBy`**: упорядочивает элементы по возрастанию

- **`OrderByDescending`**: упорядочивает элементы по убыванию

- **`ThenBy`**: задает дополнительные критерии для упорядочивания элементов возрастанию

- **`ThenByDescending`**: задает дополнительные критерии для упорядочивания элементов по убыванию

- **`Join`**: соединяет две коллекции по определенному признаку

- **`Aggregate`**: применяет к элементам последовательности агрегатную функцию, которая сводит их к одному объекту

- **`GroupBy`**: группирует элементы по ключу

- **`ToLookup`**: группирует элементы по ключу, при этом все элементы добавляются в словарь

- **`GroupJoin`**: выполняет одновременно соединение коллекций и группировку элементов по ключу

- **`Reverse`**: располагает элементы в обратном порядке

- **`All`**: определяет, все ли элементы коллекции удовлетворяют определенному условию

- **`Any`**: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию

- **`Contains`**: определяет, содержит ли коллекция определенный элемент

- **`Distinct`**: удаляет дублирующиеся элементы из коллекции

- **`Except`**: возвращает разность двух коллекцию, то есть те элементы, которые создаются только в одной коллекции

- **`Union`**: объединяет две однородные коллекции

- **`Intersect`**: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях

- **`Count`**: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию

- **`Sum`**: подсчитывает сумму числовых значений в коллекции

- **`Average`**: подсчитывает среднее значение числовых значений в коллекции

- **`Min`**: находит минимальное значение

- **`Max`**: находит максимальное значение

- **`Take`**: выбирает определенное количество элементов

- **`Skip`**: пропускает определенное количество элементов

- **`TakeWhile`**: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно

- **`SkipWhile`**: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы

- **`Concat`**: объединяет две коллекции

- **`Zip`**: объединяет две коллекции в соответствии с определенным условием

- **`First`**: выбирает первый элемент коллекции

- **`FirstOrDefault`**: выбирает первый элемент коллекции или возвращает значение по умолчанию

- **`Single`**: выбирает единственный элемент коллекции, если коллекция содержит больше или меньше одного элемента, то генерируется исключение

- **`SingleOrDefault`**: выбирает единственный элемент коллекции. Если коллекция пуста, возвращает значение по умолчанию. Если в коллекции больше одного элемента, генерирует исключение

- **`ElementAt`**: выбирает элемент последовательности по определенному индексу

- **`ElementAtOrDefault`**: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона

- **`Last`**: выбирает последний элемент коллекции

- **`LastOrDefault`**: выбирает последний элемент коллекции или возвращает значение по умолчанию

#### Лямбда-выражения
<dfn title="лямбда-выражение">Лямбда-выражения</dfn> — разделенный запятыми список параметров, за которым следует лямбда-операция (в C# `=>`), а за ней — выражение или блок операторов:
```
(параметр1, параметр2, параметр3) => выражение
```

```cs
x => x // ввод x, возвращает x

(x, y) => x == y // ввод x, y
// возвращает результат x == y
```

Может применяться блок операторов:
```cs
(параметр1, параметр2, параметр3) =>
{
  оператор1;
  оператор2;
  оператор3;
  return(тип_возврата_лямбда_выражения);
}
```

```cs
(x, y) =>
{
  if (x > y)
    return (x);
  else
    return (y);
}
```

*[Преобразовать массив строк в массив типа `int` и отсортировать по возрастанию](./samples/01_LINQ/02_LambdaExp/Program.cs)*:
```cs
string[ ] numbers = { "40", "2012", "176", "5" };

int[ ] nums = numbers.Select(s => Int32.Parse(s)).OrderBy(s => s).ToArray( );

foreach (int i in nums)
  Console.WriteLine(i);
```

<details>
<summary><em>Output</em></summary>

```
5
40
176
2012
```

</details>

#### LINQ: Фильтрация where
*Выбрать все четные элементы, которые больше 10*:
```cs
int[ ] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };

IEnumerable<int> evens =  from i in numbers
                          where i % 2 == 0 && i > 10
                          select i;

foreach (int i in evens)
  Console.WriteLine(i);

```

<details>
<summary><em>Output</em></summary>

```
34
66
88
```

</details>

*С помощью метода расширения*:
```cs
int[ ] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };

IEnumerable<int> evens =  numbers.Where(i => i % 2 == 0 && i > 10);

foreach (int i in evens)
  Console.WriteLine(i);

```

*Выбрать все имена, длина которых меньше 6*:
```cs
string[ ] names = { "Adams", "Arthur", "Buchanan", "Bush", "Carter", "Cleveland", "Clinton", "Coolidge", "Eisenhower", "Fillmore", "Ford", "Garfield", "Grant", "Harding", "Harrison", "Hayes", "Hoover", "Jackson", "Jefferson", "Johnson", "Kennedy", "Lincoln", "Madison", "McKinley", "Monroe", "Nixon", "Obama", "Pierce", "Polk", "Reagan", "Roosevelt", "Taft", "Taylor", "Truman", "Tyler", "Van Buren", "Washington", "Wilson" };

IEnumerable<string> sequence =  from n in names
                                where n.Length < 6
                                select n;
```

<details>
<summary><em>Output</em></summary>

```
Adams
Bush
Ford
Grant
Hayes
Nixon
Obama
Polk
Taft
Tyler
```

</details>

*С помощью метода расширения*:
```cs
string[ ] names = { "Adams", "Arthur", "Buchanan", "Bush", "Carter", "Cleveland", "Clinton", "Coolidge", "Eisenhower", "Fillmore", "Ford", "Garfield", "Grant", "Harding", "Harrison", "Hayes", "Hoover", "Jackson", "Jefferson", "Johnson", "Kennedy", "Lincoln", "Madison", "McKinley", "Monroe", "Nixon", "Obama", "Pierce", "Polk", "Reagan", "Roosevelt", "Taft", "Taylor", "Truman", "Tyler", "Van Buren", "Washington", "Wilson" };

IEnumerable<string> sequence =  names
                                .Where(n => n.Length < 6)
                                .Select(n => n);
```

[Example Code](./samples/01_LINQ/03_Where/Program.cs)

#### LINQ: Сложные фильтры where
*Выбрать всех пользователей старше 25 лет*
```cs
class User
{
  public string Name { get; set; }
  public int Age { get; set; }
  public List<string> Languages { get; set; }
  public User()
  {
    Languages = new List<string>( );
  }
}

List<User> users = new List<User>
{
  new User { Name="Том", Age=23, Languages = new List<string> {"английский", "немецкий"} },
  new User { Name="Боб", Age=27, Languages = new List<string> {"английский", "французский"} },
  new User { Name="Джон", Age=29, Languages = new List<string> {"английский", "испанский"} },
  new User { Name="Элис", Age=24, Languages = new List<string> {"испанский", "немецкий"} }
}

var selectedUsers = from user in users
                    where user.Age > 25
                    select user;

foreach (User user in selectedUsers)
  Console.WriteLine($"{user.Name} - {user.Age}");
```

<details>
<summary><em>Output</em></summary>

```
Боб - 27
Джон - 29
```

</details>

*С помощью метода расширения*:
```cs
var selectedUsers = users.Where(u => u.Age > 25);
```

*Отфильтровать пользователей по языку и возрасту*:
```cs
var selectedUsers = from user in users
                    from lang in user.Languages
                    where user.Age < 28
                    where lang == "английский"
                    select user;
```

<details>
<summary><em>Output</em></summary>

```
Том - 23
Боб - 27
```

</details>

*С помощью метода расширения*:
```cs
var selectedUsers = users.SelectMany(u => u.Languages,
                    (u, l) => new { User = u, Lang = l })
                    .Where(u => u.Lang == "английский" && u.User.Age < 28)
                    .Select(u => u.User);

```

**`SelectMany`** принимает последовательность, которую надо проецировать, и функцию преобразования, которая применяется к каждому элементу; возвращает 8 пар "пользователь - язык" (`new { User = u, Lang = l }`), к которым потом применяется фильтр `Where`.

[Example Code](./samples/01_LINQ/04_WhereComplex/Program.cs)

#### LINQ: проекция select
Проекция позволяет получить из текущего типа выборки какой-то другой тип.

*Получить список только имён*:
```cs
var names = from u in users select u.Name;

foreach (string n in names)
  Console.WriteLine(n);
```

<details>
<summary><em>Output</em></summary>

```
Том
Боб
Джон
Элис
```

</details>

*Получить список из имени и года рождения*:
```cs
var items = from u in users
            select new
            {
              FirstName = u.Name,
              DateOfBirth = DateTime.Now.Year - u.Age
            };

foreach (var n in items)
  Console.WriteLine($"{n.FirstName} - {n.DateOfBirth}");
```

<details>
<summary><em>Output</em></summary>

```
Том - 1996
Боб - 1992
Джон - 1990
Элис - 1995
```

</details>

*С помощью метода расширения*:
```cs
var names = users.Select(u => u.Name);

var items = users.Select(u => new
{
  FirstName = u.Name,
  DateOfBirth = DateTime.Now.Year - u.Age
});
```

[Example Code](./samples/01_LINQ/05_Select/Program.cs)

#### LINQ: переменные и `let`
Переменные для промежуточных вычислений.

*Список имен с приставкой Mr.*:
```cs
var people =  from u in users
              let name = "Mr." + u.Name
              select new
              {
                Name = name,
                Age = u.Age
              };

foreach (var p in people)
  Console.WriteLine(p.Name);
```

<details>
<summary><em>Output</em></summary>

```
Mr. Том
Mr. Боб
Mr. Джон
Mr. Элис
```

</details>

С помощью метода расширения нельзя :(

[Example Code](./samples/01_LINQ/06_Let/Program.cs)

#### LINQ: выборка из нескольких источников
```cs
class Phone
{
  public string Name { get; set; }
  public string Company { get; set; }
}

class User
{
  public string Name { get; set; }
  public int Age { get; set; }
}

List<User> users = new List<User>( )
{
  new User { Name = "Sam", Age = 43 },
  new User { Name = "Tom", Age = 33 }
};
List<Phone> phones = new List<Phone>( )
{
  new Phone {Name="Lumia 630", Company="Microsoft"},
  new Phone {Name="iPhone 6", Company="Apple"}
};

var people =  from user in users
              from phone in phones
              select new { Name = user.Name, Phone = phone.Name };

foreach (var p in people)
  Console.WriteLine($"{p.Name} = {p.Phone}");
```

<details>
<summary><em>Output</em></summary>

```
Sam - Lumia 630
Sam - iPhone 6
Tom - Lumia 630
Tom - iPhone 6
```

</details>

[Example Code](./samples/01_LINQ/07_MultiSrc/Program.cs)

#### LINQ: сортировка orderby
Оператор `orderby` принимает критерий сортировки (по умолчанию — по возрастанию):

- **`ascending`** — по возрастанию;
- **`descending`** — по убыванию.

*Отсортировать по возрастанию*:
```cs
int [] numbers = { 3, 12, 4, 10, 34, 20, 55, -66, 77, 88, 4 };
var orderedNumbers =  from i in numbers
                      orderby i
                      select i;

foreach (in i in orderedNumbers)
  Console.WriteLine(i);
```

<details>
<summary><em>Output</em></summary>

```
-66
3
4
4
10
12
20
34
55
77
88
```

</details>

*С помощью метода расширения*:
```cs
IEnumerable<int> sortedNumbers = numbers.OrderBy(i => i);
```

*По убыванию*:
```cs
var orderedNumbers =  from i in numbers
                      orderby i descending
                      select i;
```

#### LINQ: сортировка сложных объектов
*Отсортировать по возрастанию*:
```cs
List<User> users = new List<User>()
{
  new User { Name = "Tom", Age = 33 },
  new User { Name = "Bob", Age = 30 },
  new User { Name = "Tom", Age = 21 },
  new User { Name = "Sam", Age = 43 }
};

var sortedUsers = from u in users
                  orderby u.Name
                  select u;

foreach (User u in sortedUsers)
  Console.WriteLine("{0} - {1}", u.Name, u.Age);
```

<details>
<summary><em>Output</em></summary>

```
Bob - 30
Sam - 43
Tom - 33
Tom - 21
```

</details>

*С помощью метода расширения*:
```cs
var sortedUsers = users.OrderBy(u => u.Name);
```

[Example Code](./samples/01_LINQ/08_Orderby/Program.cs)

#### LINQ: множественные критерии сортировки
*Отсортировать по возрастанию*:
```cs
List<User> users = new List<User>()
{
  new User { Name = "Tom", Age = 33 },
  new User { Name = "Bob", Age = 30 },
  new User { Name = "Tom", Age = 21 },
  new User { Name = "Sam", Age = 43 }
};

var sortedUsers = from user in users
                  orderby user.Name, user.Age
                  select user;

foreach (User u in sortedUsers)
  Console.WriteLine("{0} - {1}", u.Name, u.Age);
```

<details>
<summary><em>Output</em></summary>

```
Bob - 30
Sam - 43
Tom - 21
Tom - 33
```

</details>

*С помощью метода расширения*:
```cs
var sortedUsers = users.OrderBy(u => u.Name).ThenBy(u => u.Age);
```

[Example Code](./samples/01_LINQ/09_MultiCriteria/Program.cs)

### Лекция Подключение БД
[6720d6c15040133e8429e59c](https://e-learn.petrocollege.ru/mod/lesson/view.php?id=302825)

SQL Server — одна из наиболее популярных систем управления базами данных, а при работе с фреймворком .NET, возможно, наиболее часто выбираемая СУБД. И в этой части руководства рассмотрим подключение к MS SQL Server.

#### Строка подключения для MS SQL Server
Для работы с MS SQL Server естественно нам потребуется MS SQL Server. Можно выбрать как полноценный MS SQL Server (в весиях Enterprise, Developer), так и MS SQL Server Express.

Про установку MS SQL Server в выпусках Developer или Express можно почитать в статье [Установка MS SQL Server 2019](https://metanit.com/sql/sqlserver/1.2.php).

Также можно использовать специально предназначенный для целей разработки и тестирования легковесный движок MS SQL Server Express LocalDB, про установку которого можно почитать в статье [Установка SQL Server Express LocalDB](https://metanit.com/sql/sqlserver/1.4.php).

Вначале необходимо определить строку подключения, которая содержит набор параметров сервера MS SQL Server. Строка подключения представляет набор параметров в виде пар `ключ=значение`, которые отделяются друг от друга точкой с запятой.

Прежде всего, определение строки подключения зависит от типа подключения: либо мы подлючаемся по логину и паролю, либо мы используем доверенное подключение (trusted connection), где не требуются логин и пароль (например, при подключении к локальному серверу SQL Server).

Если подключение производится по логину и паролю, то общий вид строки подключения выглядит следующим образом:

```cs
Server=адрес_сервера;Database=имя_базы_данных;User Id=логин;Password=пароль;
```

В данном случае строка подключения состоит из четырех параметров:

- `Server`: указывает на название сервера

- `Database`: указывает на название базы данных на сервере

- `User Id`: логин

- `Password`: пароль

Если мы используем так называемое доверенное подключение (trusted connection) и применяем аутентификацию Windwows, например, при подключении к локальному серверу, который запущен на том же компьютере, то строка подключения в общем виде выглядит следующим образом:

```cs
Server=адрес_сервера;Database=имя_базы_данных;Trusted_Connection=True;
```

Вместо параметров `User Id` и `Password`, здесь применяется параметр `Trusted_Connection=True`. Значение `True` указывает, что будет применяться аутентификация на основе учетных записей Windows.

Список основных параметров строки подключения, которые могут использоваться:

- `Application Name`: название приложения. Может принимать в качестве значения любую строку. Значение по умолчанию: ".Net SqlClient Data Provide"

- `AttachDBFileName`: хранит полный путь к прикрепляемой базе данных

- `Connect Timeout`: временной период в секундах, через который ожидается установка подключения. Принимает одно из значений из интервала 0–32767. По умолчанию равно 15.

  В качестве альтернативного названия параметра может использоваться `Connection Timeout`

- `Server`: название экземпляра SQL Servera, с которым будет идти взаимодействие. Это может быть название локального сервера, например, "./SQLEXPRESS", "localhost", либо сетевой адрес.

  В качестве альтернативного названия параметра можно использовать `Data Source`, `Address`, `Addr` и `NetworkAddress`

- `Encrypt`: устанавливает шифрование SSL при подключении. Может принимать значения `true`, `false`, `yes` и `no`. По умолчанию значение `false`

- `Database`: хранит имя базы данных

  В качестве альтернативного названия параметра можно использовать `Initial Catalog`

- `Trusted_Connection`: задает режим аутентификации. Может принимать значения `true`, `false`, `yes`, `no` и `sspi`. По умолчанию значение `false`

  Если значение `true`, то для аутентификации будет использоваться текущая учетная запись Windows. Подходит для подключения к локальному серверу.

  В качестве альтернативного названия параметра может использоваться `Integrated Security`

- `Packet Size`: размер сетевого пакета в байтах. Может принимать значение, которое кратно 512. По умолчанию равно 8192

- `Persist Security Info`: указывает, должна ли конфиденциальная информация передаваться обратно при подключении. Может принимать значения `true`, `false`, `yes` и `no`. По умолчанию значение `false`

- `Pooling`: если значение равно `true`, любое новое подключение при его закрытии добавляется в пул подключений. В следующий раз при создании такого же подключения (которое имеет ту же самую строку подключения) оно будет извлекаться из пула. Может принимать значения `true`, `false`, `yes` и `no`. По умолчанию значение `true`

- `Workstation ID`: указывает на рабочую станцию — имя локального компьютера, на котором запущен SQL Server

- `Password`: пароль пользователя

- `User ID`: логин пользователя

В данном случае мы будем использовать к локальному серверу. Если мы подключаемся к полноценному серверу MS SQL Server (например, версия Developer Edition), то в качестве адреса сервера, как правило, выступает `localhost`:

```cs
string connectionString = "Server=localhost;Database=master;Trusted_Connection=True;";
// альтернатива
// string connectionString = "Server=.;Database=master;Trusted_Connection=True;";
```

Если установлен MS SQL Server Express, то адрес сервера — ".\SQLEXPRESS"

```cs
string connectionString = "Server=.\SQLEXPRESS;Database=master;Trusted_Connection=True;";
```

Для подключения к localdb применяется адрес `(localdb)\mssqllocaldb`:

```cs
string connectionString = "Server=(localdb)\\mssqllocaldb;Database=master;Trusted_Connection=True"
```

Для работы с базой данных MS SQL Server в .NET 5 и выше (а также .NET Core 3.0/3.1) необходимо установить в проект через nuget пакет Microsoft.Data.SqlClient:

![Picture 1.1](./img/6720d6c15040133e8429e59c-1.1.png)

<details>
<summary><em>How to install SQLClient</em></summary>

1. "Open Manage NuGet Packages..." from the context menu of Solution Explorer.

    ![Manage NuGet Packages](./img/manage-nuget-packages.png)

2. Go "Browse" tab and put the "SqlClient" string into the search box.

    ![Search for SQL Client](./img/search-sql-client.png)

3. Choose between the "Microsoft.Data.SqlClient" (preferred) or "System.Data.SqlClient" packages, click the download arrow and proceed to the installation process accepting all the agreements.

Пространство имен `Microsoft.Data.SqlClient` по сути является новой версией пространства имен `System.Data.SqlClient`. `Microsoft.Data.SqlClient` обычно поддерживает те же API и обратную совместимость, что и `System.Data.SqlClient`. Для большинства приложений переход с `System.Data.SqlClient` на `Microsoft.Data.SqlClient` не составляет проблем. Добавьте зависимость NuGet в `Microsoft.Data.SqlClient`, после чего обновите ссылки и инструкции using в `Microsoft.Data.SqlClient`.

В этой версии пространства имен есть несколько различий в менее используемых API по сравнению с `System.Data.SqlClient`, которые могут повлиять на некоторые приложения. Для этих различий обратитесь к полезному памятку по переносу.[^introduction-microsoft-data-sqlclient-namespace]

[^introduction-microsoft-data-sqlclient-namespace]: [Введение в пространство имен Microsoft.Data.SqlClient](https://learn.microsoft.com/ru-ru/sql/connect/ado-net/introduction-microsoft-data-sqlclient-namespace?view=sql-server-ver16)

</details>

Для создания подключения к MS SQL Server применяется класс `SqlConnection` из пространства имен `Microsoft.Data.SqlClient`.

Этот класс имеет три конструктора:

```cs
SqlConnection()
SqlConnection(String)
SqlConnection(String, SqlCredential)
```

Второй и третий конструкторы в качестве первого параметра принимают строку подключения. Третий конструктор также принимает объект `SqlCredential`, который фактически представляет логин и пароль.

Теперь проверим подключение на примере сервера `LocalDB`:
```cs
using Microsoft.Data.SqlClient;
using System;
using System.Data;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static async Task Main(string[] args)
        {
            string connectionString = "Server=(localdb)\\mssqllocaldb;Database=master;Trusted_Connection=True;";

            // Создание подключения
            SqlConnection connection = new SqlConnection(connectionString);
            try
            {
                // Открываем подключение
                await connection.OpenAsync();
                Console.WriteLine("Подключение открыто");
            }
            catch (SqlException ex)
            {
                Console.WriteLine(ex.Message);
            }
            finally
            {
                // если подключение открыто
                if (connection.State == ConnectionState.Open)
                {
                    // закрываем подключение
                    await connection.CloseAsync();
                    Console.WriteLine("Подключение закрыто...");
                }
            }
            Console.WriteLine("Программа завершила работу.");
            Console.Read();
        }
    }
}
```

В данном случае подключение осуществляется к серверу `LocalDB` и его базе данных `master` (по умолчанию база данных `master` уже должна быть на любом MS SQL Servere).

Для начала взаимодействия с базой данных нам надо открыть подключение с помощью методов `Open()` (синхронный) или `OpenAsync()` (асинхронный).

По окончании работы с `SqlConnection` необходимо закрыть подключение к серверу, вызвав метод `Close()`/`CloseAsync()` или `Dispose()`/`DisposeAsync()`. В данном случае вначале проверяем, что подключение открыто и, если оно открыто, вызываем асинхронный метод `OpenAsync()`.

В итоге, если указана валидная строка подключения, то мы должны увидеть на консоли следующие строки:
```
Подключение открыто
Подключение закрыто...
Программа завершила работу.
```

Вместо явного закрытия подключения также можно использовать конструкцию `using`, которая автоматически закрывает подключение:
```cs
using Microsoft.Data.SqlClient;
using System;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static async Task Main(string[] args)
        {
            string connectionString = "Server=(localdb)\\mssqllocaldb;Database=master;Trusted_Connection=True;";
            using(SqlConnection connection = new SqlConnection(connectionString))
            {
                await connection.OpenAsync();
                Console.WriteLine("Подключение открыто");
            }
            Console.WriteLine("Подключение закрыто...");
            Console.WriteLine("Программа завершила работу.");
            Console.Read();
        }
    }
}
```

#### Получение информации о подключении
Объект `SqlConnection` обладает рядом свойств, которые позволяют получить информацию о подключении:
```cs
using Microsoft.Data.SqlClient;
using System;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static async Task Main(string[] args)
        {
            string connectionString = "Server=(localdb)\\mssqllocaldb;Database=master;Trusted_Connection=True;";

            using(SqlConnection connection = new SqlConnection(connectionString))
            {
                await connection.OpenAsync();
                Console.WriteLine("Подключение открыто");
                // Вывод информации о подключении
                Console.WriteLine("Свойства подключения:");
                Console.WriteLine($"\tСтрока подключения: {connection.ConnectionString}");
                Console.WriteLine($"\tБаза данных: {connection.Database}");
                Console.WriteLine($"\tСервер: {connection.DataSource}");
                Console.WriteLine($"\tВерсия сервера: {connection.ServerVersion}");
                Console.WriteLine($"\tСостояние: {connection.State}");
                Console.WriteLine($"\tWorkstationld: {connection.WorkstationId}");
            }
            Console.WriteLine("Подключение закрыто...");
            Console.WriteLine("Программа завершила работу.");
            Console.Read();
        }
    }
}
```

```
Подключение открыто
Свойства подключения:
	Строка подключения:
	База данных: master
	Сервер: (localdb)\mssqllocaldb
	Версия сервера: 15.00.2000
	Состояние: Open
	WorkstationId: EUGENEPC
Подключение закрыто...
Программа завершила работу.
```

### Пример подключения
[679511615040133e8429ecc9](https://e-learn.petrocollege.ru/mod/page/view.php?id=302826)

```cs
SqlConnection myConnection = new SqlConnection("Server = pcsqlstud01;database = 10171655;  Integrated Security=True;");

try
{
    myConnection.Open();
    SqlCommand myCommand = new SqlCommand("Select * from Cars", myConnection);
    string selectquery = "Select * from Cars";
    SqlDataAdapter adpt = new SqlDataAdapter(selectquery, myConnection);

    DataTable table = new DataTable();
    adpt.Fill(table);
    dataGridView1.DataSource = table;
}
catch (Exception e)
{
    Console.WriteLine(e.ToString());
}

```

### Работа с бд
[679618625040133e8429eccd](https://e-learn.petrocollege.ru/mod/assign/view.php?id=302827)

ООО «Стройматериалы» — магазин по продаже строительных материалов в Сыктывкаре.

Даны данные о товарах. Необходимо разработать бд и приложение, которое будет выводить данные о товарах, изменять, удалять и добавлять новые товары.

Визуальные компоненты должны соответствовать руководству по стилю, предоставленному в качестве ресурсов к заданию в соответствующем файле. Обеспечьте соблюдение требований всех компонентов в следующих областях:

- цветовая схема,

- размещение логотипа,

- использование шрифтов,

- установка иконки приложения.

Все компоненты системы должны иметь единый согласованный внешний вид, соответствующий руководству по стилю, а также следующим требованиям:

- разметка и дизайн (предпочтение отдается масштабируемой компоновке;

- должно присутствовать ограничение на минимальный размер окна;

- должна присутствовать возможность изменения размеров окна, где это необходимо;

- увеличение размеров окна должно увеличивать размер контентной части, например, таблицы с данными из БД);

- группировка элементов (в логические категории);

- использование соответствующих элементов управления (например, выпадающих            списков для отображения подстановочных значений из базы данных);

- расположение и выравнивание элементов (метки, поля для ввода и т.д.);

- последовательный переход фокуса по элементам интерфейса (по нажатию клавиши <kbd>TAB</kbd>);

- общая компоновка логична, понятна и проста в использовании;

- последовательный пользовательский интерфейс, позволяющий перемещаться между существующими окнами в приложении (в том числе обратно, например, с помощью кнопки «Назад»);

- соответствующий заголовок на каждом окне приложения (не должно быть значений по умолчанию типа `MainWindow`, `Form1` и тп).

Уведомляйте пользователя о совершаемых им ошибках или о запрещенных в рамках задания действиях, запрашивайте подтверждение перед удалением, предупреждайте о неотвратимых операциях, информируйте об отсутствии результатов поиска и т.п. Окна сообщений соответствующих типов (например, ошибка, предупреждение, информация) должны отображаться с соответствующим заголовком и пиктограммой. Текст сообщения должен быть полезным и информативным, содержать полную информацию о совершенных ошибках пользователя и порядок действий для их исправления. Также можно использовать визуальные подсказки для пользователя при вводе данных.

Не позволяйте пользователю вводить некорректные значения в текстовые поля сущностей. Например, в случае несоответствия типа данных или размера поля введенному значению. Оповестите пользователя о совершенной им ошибке.

Обратите внимание на использование абсолютных и относительных путей к изображениям. Приложение должно корректно работать, в том числе и при перемещении папки с исполняемым  файлом.

При возникновении непредвиденной ошибки приложение не должно аварийно завершать работу.

Идентификаторы переменных, методов и классов должны отражать суть и/или цель их использования, в том числе и наименования элементов управления (например, не должно быть значений по умолчанию типа `Form1`, `button3`).

Идентификаторы должны соответствовать соглашению об именовании (Code Convention) и стилю CamelCase (для C#).

Допустимо использование не более одной команды в строке.

#### Руководство по стилю

##### Общие требования
При создании приложения руководствуйтесь требованиями, описанными в документе «Требования и рекомендации.pdf». Не допускайте орфографические и грамматические ошибки.

##### Использование логотипа
Все экранные формы пользовательского интерфейса должны иметь заголовок с логотипом (в ресурсах). Не искажайте логотип (не изменяйте изображение, его пропорции, цвет).

Также для приложений должна быть установлена иконка.

##### Шрифт
Используйте шрифт *Comic Sans MS*.

##### Цветовая схема
В	качестве основного фона используется белый цвет; в качестве дополнительного: RGB (118, 227, 131).

Для акцентирования внимания пользователя на целевое действие интерфейса используйте цвет RGB (73, 140,81).

<table>
<thead>
  <tr>
    <th>Основной фон</th><th>Дополнительный фон</th><th>Акцентирование внимания</th>
  </tr>
<thead>
<tbody>
  <tr>
    <td>RGB</td><td>RGB</td><td>RGB</td>
  </tr>
  <tr>
    <td>(255, 255, 255)</td><td>(118, 227, 131)</td><td>(73, 140,81)</td>
  </tr>
</tbody>
<tfoot>
  <tr>
    <td style="height: 20px; background: rgb(255, 255, 255)"></td>
    <td style="height: 20px; background: rgb(118, 227, 131)"></td>
    <td style="height: 20px; background: rgb(73, 140,81)"></td>
  </tr>
</tfoot>
</table>

#### Ресурсы
Все необходимые ресурсы находятся по следующей ссылке:
- [Ресурсы](./res/00%2053-02в%2053-03в/03%20Работа%20с%20бд%20-%20Задание/)

##### Данные

| Артикул | Наименование                          | Единица измерения | Стоимость | Размер максимально возможной скидки | Производитель     | Поставщик         | Категория товара                         | Действующая скидка | Кол-во на складе | Описание                                                                                                    | Изображение |
| ------- | -------------------------------------- | ----------------- | --------- | ----------------------------------- | ----------------- | ----------------- | ---------------------------------------- | ------------------ | ---------------- | ----------------------------------------------------------------------------------------------------------- | ----------- |
| PMEZMH  | Цемент                                 | шт.               | 440       | 10                                  | М500              | М500              | Общестроительные материалы               | 8                  | 34               | Цемент Евроцемент М500 Д0 ЦЕМ I 42,5 50 кг                                                                  | PMEZMH.jpg  |
| BPV4MM  | Пленка техническая                     | шт.               | 8         | 13                                  | Изостронг         | Изостронг         | Общестроительные материалы               | 8                  | 2                | Пленка техническая полиэтиленовая Изостронг 60 мк 3 м рукав 1,5 м, пог.м                                    | BPV4MM.jpg  |
| JVL42J  | Пленка техническая                     | шт.               | 13        | 1                                   | Изостронг         | Изостронг         | Общестроительные материалы               | 4                  | 34               | Пленка техническая полиэтиленовая Изостронг 100 мк 3 м рукав 1,5 м, пог.м                                   | JVL42J.jpg  |
| F895RB  | Песок строительный                     | шт.               | 102       | 17                                  | Knauf             | Knauf             | Общестроительные материалы               | 6                  | 7                | Песок строительный 50 кг                                                                                    | F895RB.jpg  |
| 3XBOTN  | Керамзит фракция                       | шт.               | 110       | 14                                  | MixMaster         | MixMaster         | Общестроительные материалы               | 5                  | 21               | Керамзит фракция 10-20 мм 0,05 куб.м                                                                        | 3XBOTN.jpg  |
| 3L7RCZ  | Газобетон                              | шт.               | 7400      | 7                                   | ЛСР               | ЛСР               | Стеновые и фасадные материалы            | 2                  | 20               | Газобетон ЛСР 100х250х625 мм D400                                                                           | 3L7RCZ.jpg  |
| S72AM3  | Пазогребневая плита                   | шт.               | 500       | 9                                   | ВОЛМА             | ВОЛМА             | Стеновые и фасадные материалы            | 5                  | 35               | Пазогребневая плита ВОЛМА Гидро 667х500х80 мм полнотелая                                                    | S72AM3.jpg  |
| 2G3280  | Угол наружный                          | шт.               | 795       | 16                                  | Vinylon           | Vinylon           | Стеновые и фасадные материалы            | 9                  | 20               | Угол наружный Vinylon 3050 мм серо-голубой                                                                  | 2G3280.jpg  |
| MIO8YV  | Кирпич                                 | шт.               | 30        | 9                                   | ВОЛМА             | ВОЛМА             | Стеновые и фасадные материалы            | 9                  | 31               | Кирпич рядовой Боровичи полнотелый М150 250х120х65 мм 1NF                                                   | MIO8YV.jpg  |
| UER2QD  | Скоба для пазогребневой плиты          | шт.               | 25        | 20                                  | Knauf             | Knauf             | Стеновые и фасадные материалы            | 8                  | 27               | Скоба для пазогребневой плиты Knauf С1 120х100 мм                                                           | UER2QD.jpg  |
| ZR70B4  | Кирпич                                 | шт.               | 16        | 3                                   | Павловский завод | Павловский завод | Стеновые и фасадные материалы            | 3                  | 26               | Кирпич рядовой силикатный Павловский завод полнотелый М200 250х120х65 мм 1NF                                |             |
| LPDDM4  | Штукатурка гипсовая                    | шт.               | 500       | 17                                  | Knauf             | Knauf             | Сухие строительные смеси и гидроизоляция | 6                  | 38               | Штукатурка гипсовая Knauf Ротбанд 30 кг                                                                     |             |
| LQ48MW  | Штукатурка гипсовая                    | шт.               | 462       | 16                                  | Weber             | Weber             | Сухие строительные смеси и гидроизоляция | 6                  | 33               | Штукатурка гипсовая Knauf МП-75 машинная 30 кг                                                              |             |
| O43COU  | Шпаклевка                              | шт.               | 750       | 9                                   | ВОЛМА             | ВОЛМА             | Сухие строительные смеси и гидроизоляция | 1                  | 16               | Шпаклевка полимерная Weber.vetonit LR + для сухих помещений белая 20 кг                                     |             |
| M26EXW  | Клей для плитки, керамогранита и камня | шт.               | 340       | 8                                   | Knauf             | Knauf             | Сухие строительные смеси и гидроизоляция | 8                  | 2                | Клей для плитки, керамогранита и камня Крепс Усиленный серый (класс С1) 25 кг                               |             |
| K0YACK  | Смесь цементно-песчаная                | шт.               | 160       | 9                                   | MixMaster         | MixMaster         | Сухие строительные смеси и гидроизоляция | 8                  | 19               | Смесь цементно-песчаная (ЦПС) 300 по ТУ MixMaster Универсал 25 кг                                           |             |
| ASPXSG  | Ровнитель                              | шт.               | 711       | 17                                  | Weber             | Weber             | Сухие строительные смеси и гидроизоляция | 10                 | 20               | Ровнитель (наливной пол) финишный Weber.vetonit 4100 самовыравнивающийся высокопрочный 20 кг                |             |
| ZKQ5FF  | Лезвие для ножа                       | шт.               | 65        | 13                                  | Hesler            | Hesler            | Ручной инструмент                        | 6                  | 6                | Лезвие для ножа Hesler 18 мм прямое (10 шт.)                                                                |             |
| 4WZEOT  | Лезвие для ножа                       | шт.               | 110       | 2                                   | Armero            | Armero            | Ручной инструмент                        | 6                  | 17               | Лезвие для ножа Armero 18 мм прямое (10 шт.)                                                                |             |
| 4JR1HN  | Шпатель                                | шт.               | 26        | 3                                   | Hesler            | Hesler            | Ручной инструмент                        | 6                  | 7                | Шпатель малярный 100 мм с пластиковой ручкой                                                                |             |
| Z3XFSP  | Нож строительный                      | шт.               | 63        | 19                                  | Hesler            | Hesler            | Ручной инструмент                        | 8                  | 5                | Нож строительный Hesler 18 мм с ломающимся лезвием пластиковый корпус                                       |             |
| I6MH89  | Валик                                  | шт.               | 326       | 12                                  | Wenzo Roma        | Wenzo Roma        | Ручной инструмент                        | 6                  | 3                | Валик Wenzo Roma полиакрил 250 мм ворс 18 мм для красок грунтов и антисептиков на водной основе с рукояткой |             |
| 83M5ME  | Кисть                                  | шт.               | 122       | 16                                  | Armero            | Armero            | Ручной инструмент                        | 9                  | 26               | Кисть плоская смешанная щетина 100х12 мм для красок и антисептиков на водной основе                         |             |
| 61PGH3  | Очки защитные                          | шт.               | 184       | 2                                   | KILIMGRIN         | KILIMGRIN         | Защита лица, глаз, головы                | 6                  | 25               | Очки защитные Delta Plus KILIMANDJARO (KILIMGRIN) открытые с прозрачными линзами                            |             |
| GN6ICZ  | Каска защитная                        | шт.               | 154       | 10                                  | Исток             | Исток             | Защита лица, глаз, головы                | 6                  | 8                | Каска защитная Исток (КАС001О) оранжевая                                                                    |             |
| Z3LO0U  | Очки защитные                         | шт.               | 228       | 19                                  | RUIZ              | RUIZ              | Защита лица, глаз, головы                | 9                  | 11               | Очки защитные Delta Plus RUIZ (RUIZ1VI) закрытые с прозрачными линзами                                      |             |
| QHNOKR  | Маска защитная                         | шт.               | 251       | 6                                   | Исток             | Исток             | Защита лица, глаз, головы                | 2                  | 22               | Маска защитная Исток (ЩИТ001) ударопрочная и термостойкая                                                   |             |
| EQ6RKO  | Подшлемник                             | шт.               | 36        | 17                                  | Husqvarna         | Husqvarna         | Защита лица, глаз, головы                | 3                  | 22               | Подшлемник для каски одноразовый                                                                            |             |
| 81F1WG  | Каска защитная                         | шт.               | 1500      | 1                                   | Delta             | Delta             | Защита лица, глаз, головы                | 2                  | 13               | Каска защитная Delta Plus BASEBALL DIAMOND V UP (DIAM5UPBCFLBS) белая                                       |             |
| 0YGHZ7  | Очки защитные                         | шт.               | 700       | 9                                   | Husqvarna         | Husqvarna         | Защита лица, глаз, головы                | 9                  | 36               | Очки защитные Husqvarna Clear (5449638-01) открытые с прозрачными линзами                                   |             |

### Авторизация WPF / Реализация авторизации и регистрации пользователя в WPF-приложении (C#) к базе данных MS SQL Server
[679831c85040133e8429ecfa](https://e-learn.petrocollege.ru/mod/resource/view.php?id=302828)

**Используемые среды**:
- MS SQL Server Management Studio
- Microsoft Visual Studio

#### Создание базы данных и подключение ее к проекту

##### Создание БД
1. Запустите MS SQL Server Management Studio.
2. Подключитесь к серверу. Например для подключения к локальному надо ввести

   ```
   (localdb)\mssqllocaldb
   ```

3. Создайте базу данных. В поле **Имя базы данных**: задайте имя БД.

    ![Create DB](./img/679831c85040133e8429ecfa-1.png)

4. Создайте в БД две таблицы в соответствии с диаграммой (`User` и `Role`), необходимые для реализации в приложении авторизации. Задайте для них ключевое поле в виде счетчика (`Спецификация идентификатора - Да`). Все поля должны быть обязательными для заполнения.

    ![Create DB](./img/679831c85040133e8429ecfa-2.png)

5. Заполните таблицы данными. Предполагаем, что у нас будет два пользователя, один из них Администратор (Степан), другой – Ученик (Наталья). Других пользователей будем добавлять через приложение.

    ![Create DB](./img/679831c85040133e8429ecfa-3.png)

    ![Create DB](./img/679831c85040133e8429ecfa-4.png)

##### Создание модели БД
1. Создайте приложение **WPF** в MS Visual Studio.
2. Добавьте в проект в окне *Обозреватель решений* папку *ApplicationData* для размещения в ней модели базы данных.

    ![Create DB Model](./img/679831c85040133e8429ecfa-5.png)

3. В папке *ApplicationData* создайте элемент **Модель ADO.NET.EDM** (имя модели можно не менять) `Model1`. Выберите нужную модель.

    ![Create DB Model](./img/679831c85040133e8429ecfa-6.png)

4. Далее ***Создать соединение***:

    ![Create DB Model](./img/679831c85040133e8429ecfa-7.png)

5. В появившемся окне написать ***Имя сервера*** (имя сервера можно взять в MS SQL Server Management Studio по команде *Свойства* в контекстном меню сервера)

    ![Create DB Model](./img/679831c85040133e8429ecfa-8.png)

6. Выбрать вариант входа на сервер. Выбрать имя базы данных.

    ![Create DB Model](./img/679831c85040133e8429ecfa-9.png)

7. Выбрать версию Framework и на последнем шаге выбрать таблицы БД.

Добавленная модель имеет вид:

![Create DB Model](./img/679831c85040133e8429ecfa-10.png)

При изменении структуры базы данных в VS необходимо удалить таблицы модели, затем на свободном месте щелкнуть правой кнопкой мыши и выбрать команду *Обновить модель из базы данных*.

В обозревателе решений проекта отображается файл созданной модели ***Model1.edmx***.

##### Подключение к БД
1. В папку ***ApplicationData*** добавить класс **`AppConnect`**, написать в нем подключение к нашей БД.

    ![DB Connect](./img/679831c85040133e8429ecfa-11.png)

    ```cs
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    namespace AcademyApp.ApplicationData
    {
        internal class AppConnect
        {
            public static AcademyEntities modelOdb;
        }
    }
    ```

2. Подключить ту же самую модель как объект к главному окну **`MainWindow`**.

    ![DB Connect](./img/679831c85040133e8429ecfa-12.png)

    ```cs
    using AcademyApp.ApplicationData;
    using System.Text;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;
    using System.Windows.Documents;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Imaging;
    using System.Windows.Navigation;
    using System.Windows.Shapes;

    namespace AcademyApp
    {
        /// <summary>
        /// Interaction logic for MainWindow.xaml
        /// </summary>
        public partial class MainWindow : Window
        {
            public MainWindow()
            {
                InitializeComponent();
                AppConnect.modelOdb = new AcademyEntities();
            }
        }
    }
    ```

**На этом Подключение БД к проекту завершено!**

##### Интерфейс приложения (главное окно)
1. Организуйте разметку главного окна приложения в соответствии с рисунком:

    ![App Interface](./img/679831c85040133e8429ecfa-13.png)

    Ширину окна установите 800, высоту 350, измените текст в строке заголовка.

    Основной контейнер компоновки в окне — `Grid`, состоящий из двух строк:
    ```xml
    <Grid.RowDefinitions>
      <RowDefinition Height="100*" />
      <RowDefinition Height="350*" />
    </Grid.RowDefinitions>
    ```

    В **верхней строке сетки `Grid`** размещен контейнер компоновки `StackPanel` с горизонтальным размещением в нем двух элементов: `Image` и `TextBlock`. Изображение логотипа поместить в папку проекта ***Resources***. Стиль оформления надписи организовать в ресурсах файла ***App.xaml***, например, в таком виде (можно изменить стиль на свое усмотрение):
    ```xml
    <Style TargetType="TextBlock" x:Key="Title">
      <Setter Property="VerticalAlignment" Value="Center"/>
      <Setter Property="FontSize" Value="13pt"/>
      <Setter Property="FontWeight" Value="Bold"/>
      <Setter Property="Margin" Value="15"/>
    </Style>
    ```

    и применить к элементу **`TextBlock`**: `Style="{StaticResource Title}"`.

    В нижней строке сетки `Grid` разместить **`Frame`**. Дать ему имя ***FrmMain***, скрыть в нем панель навигации: `NavigationUIVisibility="Hidden"`.

2. Чтобы внутри данного фрейма выполнять действия (хранить и передавать информацию из страницы к странице), создадим специальный класс, и объект этого класса с именем FrmMain.

    В папку ***ApplicationData*** добавьте класс `AppFrame`:

    ![App Interface](./img/679831c85040133e8429ecfa-14.png)

    ```cs
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows.Controls;

    namespace AcademyApp.ApplicationData
    {
        internal class AppFrame
        {
            public static Frame frameMain;
        }
    }
    ```

    Пропишите фрейм в коде главного окна:

    ![App Interface](./img/679831c85040133e8429ecfa-15.png)

    ```cs
    using AcademyApp.ApplicationData;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;
    using System.Windows.Documents;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Imaging;
    using System.Windows.Navigation;
    using System.Windows.Shapes;

    namespace AcademyApp
    {
        /// <summary>
        /// Interaction logic for MainWindow.xaml
        /// </summary>
        public partial class MainWindow : Window
        {
            public MainWindow()
            {
                InitializeComponent();
                AppConnect.modelOdb = new AcademyEntities();
                AppFrame.frameMain = FrmMain;
            }
        }
    }
    ```

##### Добавление страниц
Для каждой вновь добавляемой страницы приложения будем организовывать в проекте отдельную папку.

###### Страница авторизации
1. Создайте в проекте папку *PagesMain*** (***Pages***). В ней создайте страницу ***PageLogin***. Установите высоту 350, ширину 800.

   - Организуйте разметку страницы в соответствии с рисунком.
   - Используйте контейнер `StackPanel`, расположите его в центре страницы.
   - Для ввода пароля используйте компонент `PasswordBox`.
   - Для оформления кнопок добавьте еще два шаблона в ресурсы файла ***APP.xaml***.
   - Между всеми компонентами страницы создайте отступы в 5 пикселей:

   ![Auth Page](./img/679831c85040133e8429ecfa-16.png)

   ![Auth Page](./img/679831c85040133e8429ecfa-17.png)

2. Данная страница авторизации должна загружаться при запуске приложения. Для этого нужно в главном окне внутри фрейма инициализировать нашу страницу:

    ![Auth Page](./img/679831c85040133e8429ecfa-18.png)

    ```cs
    using AcademyApp.ApplicationData;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;
    using System.Windows.Documents;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Imaging;
    using System.Windows.Navigation;
    using System.Windows.Shapes;

    namespace AcademyApp
    {
        /// <summary>
        /// Interaction logic for MainWindow.xaml
        /// </summary>
        public partial class MainWindow : Window
        {
            public MainWindow()
            {
                InitializeComponent();
                AppConnect.modelOdb = new AcademyEntities();
                AppFrame.frameMain = FrmMain;

                FrmMain.Navigate(new Pages.PageLogin());
            }
        }
    }
    ```

**Запустите проект, убедитесь, что страница авторизации загружается в окне приложения!**

![Auth Page](./img/679831c85040133e8429ecfa-19.png)

##### Функционал авторизации
Создайте обработчик события `Click` для кнопки ***Войти***.

```cs
try
{
  var userObj = AppConnect.modelOdb.User.FirstOrDefault(x => x.Login == txbLogin.Text && x.Password == psbPassword.Password);
  if (userObj==null)
  {
    MessageBox.Show("Такого пользователя нет!", "Ошибка при авторизации!",
      MessageBoxButton.OK, MessageBoxImage.Error);
  }
  else
  {
    switch (userObj.IdRole)
    {
      case 1: MessageBox.Show("Здравствуйте, Администратор " + userObj.Name + "!",
        "Уведомление", MessageBoxButton.OK, MessageBoxImage.Information);
        break;
      case 2:
        MessageBox.Show("Здравствуйте, Ученик " + userObj.Name + "!",
          "Уведомление", MessageBoxButton.OK, MessageBoxImage.Information);
        break;
      default: MessageBox.Show("Данные не обнаружены!", "Уведомление", MessageBoxButton.OK, MessageBoxImage.Warning);
        break;
    }
  }
}
catch (Exception Ex)
{
  MessageBox.Show("Ошибка " + Ex.Message.ToString() + "Критическая ошибка приложения!",
  "Уведомление", MessageBoxButton.OK, MessageBoxImage.Warning);
}
```

_Пояснения к коду_:

Когда идет работа с данными рекомендуют использовать `try..catch` (обработку исключений).

Внутри оператора `try` нужно написать процесс подключения к базе данных и работы с ней.
```cs
var userObj = AppConnect.modelOdb.User.FirstOrDefault(x =>
x.Login  == txbLogin.Text && x.Password == psbPassword.Password);
```

Создадим динамическую переменную **`userObj`**. Будем внутри нее хранить данные, получаемые из полей для ввода логина и пароля.

Обращаться к БД будем посредством созданного нами ранее класса **`AppConnect`** и работать непосредственно с ним.

![Auth Page](./img/679831c85040133e8429ecfa-20.png)

Модель `modelOdb` видит входящие в БД таблицы в качестве атрибутов (`User`).

При наборе строки
```cs
var userObj = AppConnect.modelOdb.User.
```

после очередной точки перечисляются методы работы с LINQ-запросами и EntityFramework.

Нам нужен метод `FirstOrDefault` (он возвращает первый элемент последовательности…).

Создаем анонимную переменную `x`, используемую внутри LINQ-запроса (аналогично параметру цикла `for`).

Возвращаем в переменную `userObj` все значения из таблицы `User`, которые совпали по введенным в текстовые поля логину и паролю.

Если в БД пользователя нет, то нужно вывести об этом сообщение (`if`…), иначе – нужно вывести приветствие для соответствующего пользователя.

**Запустите проект, убедитесь, что на экран выводится каждое из организованных в коде приветствий и уведомлений!**

[Solution Example](./samples/03_AcademyApp/MainWindow.xaml)

### Задание на авторизацию и создание бд
[679858275040133e8429ecfc](https://e-learn.petrocollege.ru/mod/assign/view.php?id=358549)

1. Разработать базу данных согласно схеме:

    ![DB Schema](./img/679858275040133e8429ecfc-1.png)

2. Заполнить базу данными, минимум 10 записей в каждой таблице.

3. Разработать страницу авторизации в VS 2022.

    ![Auth page](./img/679858275040133e8429ecfc-2.png)

4. Подключить бд к приложению

    ![Auth page](./img/679858275040133e8429ecfc-3.png)

5. Запрограммировать кнопку Войти

    ![Login page](./img/679858275040133e8429ecfc-4.png)

[Solution](./src/pw/02_BookAuth/MainWindow.xaml)

### Регистрация WPF
[6799fb9c5040133e8429ed29](https://e-learn.petrocollege.ru/mod/assign/view.php?id=358550)

#### Реализация регистрации пользователя в WPF-приложении (C#) к базе данных MS SQL Server (практическая работа)
https://e-learn.petrocollege.ru/pluginfile.php/542787/mod_assign/introattachment/0/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F%20%D0%B2%20WPF-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8%20%D0%BA%20%D0%B1%D0%B0%D0%B7%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20MS%20SQL%20Server_%20%281%29.docx?forcedownload=1

**Используемые среды**:
- MS SQL Server Management Studio
- Microsoft Visual Studio

##### Страница регистрации

1. В папке *PageMain* создайте страницу *PageCreateAcc*. Установите высоту страницы 350, ширину – 800.

    Создадим интерфейс для возможности отправки в БД введенных значений нового пользователя.

    ![Picture 1](./img/6799fb9c5040133e8429ed29-1.png)

    - Организуйте разметку страницы в соответствии с рисунком.
    - Используйте контейнер `StackPanel` с вертикальной ориентацией, разместите его в центре страницы.
    - В нем организуйте еще 4 контейнера `StackPanel` горизонтальной ориентацией.
    - Для ввода пароля используйте компонент `TextBox`, для подтверждения пароля – `PasswordBox`.
    - Оформление компонентов организуйте с помощью стилей, шаблоны которых пропишите в файле *App.xaml*.
    - По нажатию на кнопку **Регистрация** страницы **Авторизация** должна открываться страница для создания аккаунта ученика. При нажатии на кнопку **Назад** страницы **Регистрация** мы должны вернуться на страницу **Авторизация**.

2. Создайте обработчик события `Click` для кнопки Регистрация:

    ```cs
    private void btnRegIn_Click(object sender, RoutedEventArgs e)
    {
      AppFrame.frameMain.Navigate(new PageCreateAcc());
    }
    ```

3. Создайте обработчик события `Click` для кнопки Назад:

    ```cs
    private void btnRegIn_Click(object sender, RoutedEventArgs e)
    {
      AppFrame.frameMain.GoBack();
    }
    ```

_Пояснения к коду_:
- Все действия на главном окне у нас выполняются во фрейме.
- Этот фрейм хранится в объекте `frameMain`.
- Мы загрузили наш фрейм с главной страницы.

**Запустите проект, убедитесь, что осуществляются соответствующие переходы по кнопкам Регистрация и Назад!**

##### Функционал прохождения регистрации ученика

1. Кнопка **Создать** должна быть недоступна, пока в поле подтверждения пароля вводимое значение не совпадет с первоначальным. А поле подтверждения пароля окрашивается красным пока нет совпадения и зеленым в момент совпадения значений в полях.

    Для этого:
    -	Кнопку Создать сделать изначально неактивной `IsEnabled="False"`
    -	Создайте обработчик события `PasswordChanged` компонента `PasswordBox`:
    ```cs
    private void PasswordBox_PasswordChanged(object sender, RoutedEventArgs e)
    {
      if (psbPass.Password!=txbPass.Text)
      {
        btnCreate.IsEnabled = false;
        psbPass.Background = Brushes.LightCoral;
        psbPass.BorderBrush = Brushes.Red;
      }
      else
      {
        btnCreate.IsEnbaled = true;
        psbPass.Background = Brushes.LightGreen;
        psbPass.BorderBrush = Brushes.Green;
      }
    }
    ```

    **Запустите проект. Убедитесь, что кнопка Создать и поле подтверждения пароля ведут себя как было запланировано!**

    ![Picture 2](./img/6799fb9c5040133e8429ed29-2.png)

    ![Picture 3](./img/6799fb9c5040133e8429ed29-3.png)

2. Внутри обработчика события `Click` кнопки **Создать** нужно организовать добавление в базу данных значений, вводимых пользователем в соответствующие текстовые поля. Для этого необходимо обратиться к таблице `User` базы данных, и эта таблица должна получить значения из компонентов страницы **Регистрация** (Имя, Логин и Пароль).

    ```cs
    private void btnCreate_Click(object sender, RoutedEventArgs e)
    {
      if (AppConnect.modelOdb.User.Count(x => x.Login==txbLogin.Text) > 0)
      {
        MessageBox.Show("Пользователь с таким логином есть!",
          "Уведомление",MessageBoxButton.OK,MessageBoxImage.Information);
        return;
      }
      try
      {
        User userObj = new User()
        {
          Login = txbLogin.Text,
          Name = txbName.Text,
          Password = txbPass.Text,
          IdRole = 2
        };
        AppConnect.modelOdb.User.Add(userObj);
        AppConnect.modelOdb.SaveChanges();
        MessageBox.Show("Данные успешно добавлены!",
          "Уведомление",MessageBoxButton.OK,MessageBoxImage.Information);
      }
      catch
      {
        MessageBox.Show("Ошибка при добавлении данных!",
          "Уведомление",MessageBoxButton.OK,MessageBoxImage.Error);
      }
    }
    ```

    _Пояснения к коду_:
    - Сначала нужно проверить, есть ли пользователь с таким логином в системе.
    - Если значения, возвращаемые из таблицы `User` по полю `Login` имеются (применяем для этой цели метод `Count` LINQ-запроса), то вывести уведомление о том, что пользователь с таким логином существует в БД.
    - Для добавления данных нового пользователя нужно использовать конструкцию `try..catch`.
    - Создаем новый объект `UserObj` класса `User`, присваиваем его свойствам значения из компонентов страницы **Регистрация**. Регистрировать можно только учеников, поэтому присваиваем значение 2 полю `idRole`. Записываем созданный объект в таблицу БД `User` (метод `Add`) и сохраняем изменения (метод `SaveChanges`). По окончании выводим уведомление о проделанной операции.

    **Запустите проект, зарегистрируйте нового ученика, осуществите вход под его аккаунтом!**

3. Измените интерфейс таким образом, чтобы название проекта отображалось в строке заголовка главного окна, а в верхней части окна каждый раз располагалось название открытой страницы (**Окно авторизации**, **Окно регистрации**).

    Изменения для этого вносим в разметку: добавляем элемент `TextBlock` и в его свойстве `Text` указываем источник текста – `Title` открытой страницы (содержимого фрейма).

    ```xml
    Text="{Binding ElementName=FrmMain,
          Path=Content.Title}"
    ```

    **Запустите проект, убедитесь в отображении заголовков открытых страниц!**

    ![Picture 4](./img/6799fb9c5040133e8429ed29-4.png)

    ![Picture 5](./img/6799fb9c5040133e8429ed29-5.png)

[Solution Example](samples/04_AcademyAppRegister/MainWindow.xaml)

### Задание Регистрация WPF
[679b50185040133e8429ed46](https://e-learn.petrocollege.ru/mod/assign/view.php?id=358551)

https://e-learn.petrocollege.ru/pluginfile.php/542788/mod_assign/introattachment/0/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8E.docx?forcedownload=1

1. Разработать страницу регистрации в VS 2022.

    ![Registration Form](./img/679b50185040133e8429ed46-1.png)

2. Добавить в базу соответствующие поля

3. Запрограммировать кнопки **Зарегистрироваться** и **Назад**

4. Подключить страницу к авторизации

[Solution](./src/pw/03_RecipeBook/MainWindow.xaml)

### Данные
[679c880a5040133e8429ed59](https://e-learn.petrocollege.ru/mod/resource/view.php?id=309444)

Сделать интернет-магазин.

### Вывод данных
[679e34c15040133e8429ed70](https://e-learn.petrocollege.ru/mod/resource/view.php?id=324518)

После разработки авторизации и регистрации добавить возможность вывода списка студентов.

Пример таблицы с информацией о студентах представлен на рисунке 1.

![Picture 1](./img/679e34c15040133e8429ed70-1.png)

Для вывода списка информации о студентах необходимо создать `ListView`. Пример оформления представлен на Рисунке 2.

```xml
<Grid>
  <Grid.ColumnDefinitions>
    <ColumnDefinition/>
  </Grid.ColumnDefinitions>
  <Grid.RowDefinitions>
    <RowDefinition Height="33"/>
    <RowDefinition Height="497"/>
    <RowDefinition Height="50"/>
  </Grid.RowDefinitions>
  <ListView x:Name="listProducts" Grid.Row="1" ScrollViewer.CanContentScroll="False">
    <ListView.ItemTemplate>
      <DataTemplate>
        <Grid>
          <Grid.ColumnDefinitions>
            <ColumnDefinitions Width="100"/>
            <ColumnDefinitions Width="700"/>
            <ColumnDefinitions Width="200"/>
          </Grid.ColumnDefinitions>
          <Image Source="{Binding CurrentPhoto}" Grid.Column="0"/>
          <StackPanel Grid.Column="1" Width="auto" Orientation="Vertical" HorizontalAlignment="Left">
            <TextBlock Width="auto" TextWrapping="Wrap" Height="auto">
              <Run Text="ФИО: "/>
              <Run Text="{Binding FIO}"/>
            </TextBlock>
            <TextBlock Width="auto" TextWrapping="Wrap" Height="auto">
              <Run Text="Курс: "/>
              <Run Text="{Binding Course}"/>
            </TextBlock>
            <TextBlock Width="auto" TextWrapping="Wrap" Height="auto">
              <Run Text="Специальность: "/>
              <Run Text="{Binding Specialty}"/>
            </TextBlock>
          </StackPanel>
          <StackPanel Grid.Column="2" Width="auto" Orientation="Vertical" HorizontalAlignment="Left">
            <TextBlock Width="auto" TextWrapping="Wrap" Height="auto">
              <Run Text="Пол: "/>
              <Run Text="{Binding Gender}"/>
            </TextBlock>
          </StackPanel>
        </Grid>
      </DataTemplate>
    </ListView.ItemTemplate>
  </ListView>
  <TextBlock x:Name="tbCounter" Text="Не найдено" Grid.Row="2" Width="95" HorizontalAlignment="Left" Height="22" Margin="695,0,0,0">
</Grid>
</Page>
```

Для присоединения базы к `ListView` необходимо добавить следующий код
```cs
public PageTask()
{
  InitializeComponent();
  List<Student> products = AppConnect.model101.Students.ToList();

  if (products.Count > 0)
  {
    tbCounter.Text = "Найдено " + products.Count + " товаров";
  }
  else
  {
    tbCounter.Text = "Не найдено";
  }
  listProducts.ItemSource = products;
}
```

Для вывода изображений в классе `Student` необходимо прописать свойство
```cs
public string Specialty { get; set; }
public string Image { get; set; }
public string CurrentPhoto {
  get
  {
    if (String.IsNullOrEmpty(Image) || String.IsNullOrWhiteSpace(Image))
    {
      return "/Images/picture.png";
    }
    else
    {
      return "/Images/" + Image;
    }
  }
}
```

[Example Solution](samples/05_AcademyApp_List/MainWindow.xaml)

### Фильтрация, поиск, сортировка
[679f415a5040133e8429ed7c](https://e-learn.petrocollege.ru/mod/resource/view.php?id=325841)

```cs
Product[] FindProduct()
{
  // В переменную product записываем список из таблицы Product
  var product = AppConnect.modelOdb.Product.ToList();
  var productall = product;
  // Поиск по названию продуктов
  if (TextSearch != null)
  {
    // ProductName1 (первое значение) - таблица с названиями
    // ProductName1 (второе значение) - столбик с названиями в таблице
    product = product.Where(x => x.ProductName1.ProductName1.ToLower().Contains(TextSearch.Text.ToLower())).ToList();
  }
  // Фильтрация по скидке
  if (ComboFilter.SelectedIndex > 0)
  {
    switch (ComboFilter.SelectedIndex)
    {
      case 1:
        product = product.Where(x => x.ProductDiscountAmount > 0 && x.ProductDiscountAmount < 10).ToList();
        break;
      case 2:
        product = product.Where(x => x.ProductDiscountAmount >= 10 && x.ProductDiscountAmount < 15).ToList();
        break;
      case 3:
        product = product.Where(x => x.ProductDiscountAmount >= 15 && x.ProductDiscountAmount >= 15).ToList();
        break;
    }
  }
  // Сортировка по возрастанию и убыванию цены
  if (ComboSort.SelectedIndex > 0)
  {
    switch (ComboSort.SelectedIndex)
    {
      case 1:
        product = product.OrderBy(x => x.ProductCost).ToList();
        break;
      case 2:
        product = product.OrderByDescending(x => x.ProductCost).ToList();
        break;
    }
  }
  // Количество элементов найденных
  if (product.Count > 0)
  {
    LabelCount.Content = "Найдено" + product.Count + " из " + productall.Count;
  }
  else
  {
    LabelCount.Content = "Ничего не найдено ";
  }
  return product.ToArray();
}
```

### Формирование qr кода
[67a23bdd5040133e8429eddd](https://e-learn.petrocollege.ru/mod/resource/view.php?id=329511)

Скачать и установить библиотеку `Aspose.BarCode.Generation`.

Метод создания и вывода картинки на экран в переменную `img` (Элемент в *xml* `Image` с именем `img`)
```cs
int a = 1;
private void btn1_Click(object sender, RoutedEventArgs e)
{
  BitmapImage bitmap = new BitmapImage();
  BarcodeGenerator gen = new BarcodeGenerator(EncodeTypes.QR, "https://bom.firpo.ru/Public/86");
  gen.Parameters.Barcode.XDimension.Pixels = 34;

  string dataDir = @"C:\Users\t.spiridonova\source\repos\WpfApp1\WpfApp1\";
  gen.Save(dataDir + a.ToString()+"1.png", BarCodeImageFormat.Png);

  //BitmapImage bitmap = new BitmapImage();
  bitmap.BeginInit();
  bitmap.UriSource = new Uri(dataDir + a.ToString() + "1.png");
  bitmap.EndInit();

  img.Source = bitmap;
  a++;
}
```

### Формирование pdf документа
[67a508be5040133e8429ee4e](https://e-learn.petrocollege.ru/mod/resource/view.php?id=329512)

Подключение библиотек:
```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
// using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Xml.Linq;
using Детское_творчество.AppData;
using iTextSharp.text;
using iTextSharp.text.pdf;
using Image = iTextSharp.text.Image;
using System.Windows.Markup;
using System.Windows.Documents;
using Paragraph = iTextSharp.text.Paragraph;
```

Метод создания pdf документа:
```cs
private void CreatePDF()
{
  // Создаем новый документ PDF
  Document doc = new Document();

  try
  {
    // Указываем путь для сохранения PDF-файла
    PdfWriter.GetInstance(doc, new FileStream("..\\..\\output.pdf", FileMode.Create));

    doc.Open();
    BaseFont baseFont = BaseFont.CreateFont("C:\\Windows\\Fonts\\Arial\\.ttf", BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);

    // Create a Font object using the BaseFont
    Font font = new Font(baseFont, 12);
    Font font1 = new Font(baseFont, 25,3,BaseColor.BLUE);
    Paragraph paragraph1 = new Paragraph("СПИСОК ТОВАРОВ", font1);
    paragraph1.Alignment = Element.ALIGN_CENTER;
    doc.Add(paragraph1);
    decimal sum = 0;
    // Получаем данные из List и добавляем их в PDF
    foreach (var item in AppConnect.modelOdb.Product.ToList())
    {
      if (item is Product) // Замените YourDataType на тип данных, используемый в вашем ListBox
      {
        Product data = (Product)item;

        // Добавляем данные из ListBox в PDF
        Image img = Image.GetInstance(@"H:\C#\WPF\ДЭ Детское творчество\Детское творчество\Детское творчество\Детское творчество\" + data.CorrectImage);
        img.ScaleAbsolute(100f, 100f); // Устанавливаем размер изображения
        doc.Add(img);
        doc.Add(new Paragraph("Название: "+data.ProductName1.ProductName1,font));
        doc.Add(new Paragraph("Описание: "+data.ProductDescription, font));
        doc.Add(new Paragraph(""+data.ProductManufacturer, font));
        doc.Add(new Paragraph("Стоимость: "+data.ProductCost.ToString() + " руб.", font));
        doc.Add(new Paragraph("Размер скидки: " + data.ProductDiscountAmount + "%", font));

        sum += data.ProductCost;
      }
    }
    Paragraph paragraph = new Paragraph("Сумма = " + sum.ToString(), font);
    paragraph.Alignment = Element.ALIGN_RIGHT;
    doc.Add(paragraph);
  }
  catch (DocumentException de)
  {
    Console.Error.WriteLine(de.Message);
  }
  catch (IOException ioe)
  {
    Console.Error.WriteLine(ioe.Message);
  }
  finally
  {
    doc.Close();
  }
}
```

Результат:

![Result](./img/67a508be5040133e8429ee4e_1.png)

### Добавление, редактирование, удаление
[67ac85d15040133e8429eef8](https://e-learn.petrocollege.ru/mod/resource/view.php?id=329519)

#### Реализация функции добавления

1. На странице `AddEditPage` добавим новое поле, которое будет хранить в себе экземпляр добавляемого отеля

   ![Picture 1](./img/67ac85d15040133e8429eef8-1.png)

2. При инициализации установим `DataContext` страницы — этот созданный объект

   ![Picture 2](./img/67ac85d15040133e8429eef8-2.png)

3. Затем, используя привязку данных, укажем, какому свойству обращаться к каждому элементу при загрузке данных. Например, свойство `Text` у первого `TextBox`'а будет обращаться к названию отеля

   ![Picture 3](./img/67ac85d15040133e8429eef8-3.png)

4. Второй элемент будет обращаться к количеству звезд

   ![Picture 4](./img/67ac85d15040133e8429eef8-4.png)

5. И комбо-бокс будет обращаться к стране, которую мы выбрали для отеля

   ![Picture 5](./img/67ac85d15040133e8429eef8-5.png)

6. Далее обработаем нажатие на кнопку *Сохранение* и в коде пропишем логику обращения к модели данных и добавления нового экземпляра отеля

   - a) Прежде чем сохранять данные, сделаем проверки на количество символов, заполняемость объектов, звездность (т. к. количество звезд должно быть от одного до пяти) и выбор страны

     ![Picture 6](./img/67ac85d15040133e8429eef8-6.png)

   - b) После прохождения проверки нужно узнать, возникли ли ошибки, обратившись к переменной `errors`. Если в переменной что-то есть, то необходимо вывести сообщение об ошибке (то, что накопилось во время проверки). Соответственно, дальнейшее выполнение функции не нужно, и с помощью оператора `return` — мы выходим

     ![Picture 7](./img/67ac85d15040133e8429eef8-7.png)

   - c) Если же все хорошо, и у нас происходит операция добавления (т.е. еще не присвоен код нового отеля), то мы будем пытаться добавить модель или экземпляр созданного отеля. Получив его контекст и обратившись к таблице отелей, с помощью метода `Add` мы добавляем созданный экземпляр

     ![Picture 8](./img/67ac85d15040133e8429eef8-8.png)

   - d) Далее напишем код для сохранения изменений, используя метод `SaveChanges`. Этот метод является коварным, его необходимо поместить в блок `try-catch`, чтобы он отработал корректно, и в случае возникновения какой-либо непредвиденной ошибки, приложение не «упало», а корректно работало. Мы выведем сообщение об ошибке, если она появилась. В случае успешного сохранения выведем сообщение о том, что информация сохранена.

     ![Picture 9](./img/67ac85d15040133e8429eef8-9.png)

7. Теперь можно вернуться назад. При возврате на страницу со списком отелей, нам необходимо выводить актуальную информацию, обновляя список в таблице. Для этого мы будем использовать событие у страницы `IsVisibleChange`. Оно срабатывает каждый раз, когда страница отображается, либо скрывается

   ![Picture 10](./img/67ac85d15040133e8429eef8-10.png)

   С помощью <kbd>F12</kbd> переходим в код. Если видимость страницы `isVisible`, мы будем обращаться к контексту с помощью свойства `ChangeTracker` ко всем сущностям, которые есть. И для каждой из них будем выполнять метод перезагрузки и вывода актуальных данных. После этого таблицу `DGridHotels` присвоим таблице «список отелей»

   ![Picture 11](./img/67ac85d15040133e8429eef8-11.png)

8. Запускаем программу и проверяем функцию добавления данных

#### Реализация функции редактирования
Для функции редактирования данных целесообразно использовать ту же страницу, что мы делали для добавления. Каким образом это будет происходить? В случае, если пользователь намерен изменить информацию об объекте, система будет отображать страницу добавления с информацией о редактируемом объекте. Измененная информация будет фиксироваться в базе данных и отображаться в списке, как было при добавлении. 

В первую очередь добавим параметр нашей странице `AddEditPage`. В нее мы будем передавать экземпляр выбранного отеля и, в случае если он не пустой, присваивать нашему полю `CurrentHotel`.

Мы не можем сейчас запустить приложение, т. к. возник ряд ошибок

![Picture 12](./img/67ac85d15040133e8429eef8-12.png)

Вызов страницы `AddEditPage` теперь требует какого-то аргумента. В случае, если мы будем делать добавление, мы просто пропишем `null` (отправим пустой экземпляр). При этом для редактирования `BtnEdit` мы уже будем передавать экземпляр прописав для этого код. Вместо `null` будем обращаться к кнопке, на которую нажали, получать ее контекст и знать, что это — отель

![Picture 13](./img/67ac85d15040133e8429eef8-13.png)

Попробуем теперь посмотреть, что получилось

![Picture 14](./img/67ac85d15040133e8429eef8-14.png)

Те данные, которые мы хотим отредактировать, автоматически привязались к этим элементам управления и отображаются корректно. В случае, если мы отредактируем какое-то поле — нажимаем на кнопку *Сохранить*. Информация будет обновлена

![Picture 15](./img/67ac85d15040133e8429eef8-15.png)

#### Реализация функции удаления
Для реализации функции удаления отдельное окно не потребуется. Это значительно сократит время на разработку, но удаление требует к себе особого внимания. Любые действия, безвозвратно изменяющие данные в базе данных, должны запрашивать подтверждение пользователя. Именно поэтому, в первую очередь, для нажатия на кнопку удаления мы реализуем сообщение с вопросом: действительно ли пользователь хочет это сделать.

Итак, получаем список отелей для удаления, обратившись к таблице с отелями. Выбираем все элементы, которые мы выделили, преобразуем их в список отелей. И затем, в сообщении, будем спрашивать пользователя: «Вы точно хотите удалить следующие `hotelsForRemoving.Count()` элементов?». Укажем здесь заголовок сообщения — «Внимание», затем укажем, какие кнопки доступны при диалоге с пользователем: «Да» или «Нет», и выберем изображение — «Question»

![Picture 16](./img/67ac85d15040133e8429eef8-16.png)

Если результатом диалога от пользователя было нажатие на кнопку «yes», то мы будем выполнять удаление. Для этого обратимся к модели данных, используя блок `TryCatch`. Получив контекст, попробуем с помощью метода `RemoveRange` удалить все полученные выделенные отели. В случае, если все будет хорошо, отобразим сообщение. Иначе, выводим сообщение об ошибке. Также, в случае, если удаление произойдет успешно, отдельно вызовем обновление актуальных данных

![Picture 17](./img/67ac85d15040133e8429eef8-17.png)

Сохраним и проверим работу приложения. Выделим два отеля

![Picture 18](./img/67ac85d15040133e8429eef8-18.png)

Нажмем удалить — точно хотим удалить следующие 2 элемента

![Picture 19](./img/67ac85d15040133e8429eef8-19.png)

### Практическая работа "Диспетчеры компоновки"
[67b44dc65040133e8429ef84](https://e-learn.petrocollege.ru/mod/assign/view.php?id=369415)

Окно WPF-приложения обычно представлено корневым элементом Window. Дочерним элементом корневого элемента является диспетчер компоновки, который в свою очередь содержит любое количество элементов (в том числе, вложенных диспетчеров компоновки), определяющих пользовательский интерфейс. Диспетчер компоновки является объектом класса, унаследованного от абстрактного класса `System.Windows.Controls.Panel`.

Основные панели (диспетчеры компоновки, контейнерные элементы управления) WPF:

| Элемент | Описание
-- | --
**`Canvas`** | Элементы остаются в точности там, где были размещены во время проектирования
**`DockPanel`** | Привязывает содержимое к определенной стороне панели (`Тор` (верхняя), `Bottom` (нижняя), `Left` (левая) или `Right` (правая))
**`Grid`** | Располагает содержимое внутри серии ячеек, расположенных в табличной сетке
**`StackPanel`** | Выводит содержимое по вертикали или горизонтали, в зависимости от значения свойства `Orientation`
**`WrapPanel`** | Позиционирует содержимое слева направо, перенося на следующую строку по достижении границы панели. Последовательность размещения происходит сначала сверху вниз или сначала слева направо, в зависимости от значения свойства `Orientation`

#### Диспетчер компоновки Canvas
Панель `Canvas` поддерживает абсолютное позиционирование содержимого пользовательского интерфейса. Если пользователь изменяет размер окна, делая его меньше, чем компоновка, обслуживаемая панелью `Canvas`, ее внутреннее содержимое становится невидимым до тех пор, пока контейнер вновь не увеличится до размера, равного или больше начального размера области `Canvas`.

Панель `Canvas`  обладает следующим недостатком: элементы внутри `Canvas` не изменяются динамически при применении стилей или шаблонов.

Рассмотрим панель Canvas со следующим содержимым:
```xml
<Canvas>
  <Label Canvas.Left="10" Canvas.Top="10" Content="Регистрация пользователя" />
  <Label Canvas.Left="10" Canvas.Top="40" Content="ФИО" />
  <TextBox Canvas.Left="70" Canvas.Top="40" Width="200" />
  <Label Canvas.Left="10" Canvas.Top="70" Content="Email" />
  <TextBox Canvas.Left="70" Canvas.Top="70" Width="200" />
  <Button Canvas.Left="50" Canvas.Top="100" Content="Зарегистрироваться" />
</Canvas>
```

У элементов управления `Label`, `TextBox`, `Button` отсутствуют атрибуты `Left` и `Top`, поэтому для определения положения элементов на панели используется синтаксис присоединяемых свойств.

##### Присоединяемые свойства XAML (attached properties)

> В XAML поддерживается специальный синтаксис, используемый для определения значения присоединяемого свойства. Присоединяемые свойства позволяют дочернему элементу устанавливать значение какого-то свойства, которое в действительности определено в родительском элементе. Общий шаблон:
>
> ```xml
> <РодительскийЭлемент>
>   <ДочернийЭлемент РодительскийЭлемент.СвойствоРодительскогоЭлемента = "Значение">
> </РодительскийЭлемент>
> ```
> С помощью присоединяемых свойств можно определить значения лишь ограниченного набора свойств родительских элементов, которые определены специальным образом в классе родительского элемента.
>
> _Дополнительное задание_: определите, каким образом присоединяемые свойства объявляются в классе родительского элемента.

<details>
<summary><em>Ответ</em></summary>

Присоединяемые свойства в XAML, используемые в WPF, позволяют задавать дополнительные свойства для элементов, которые не определяют эти свойства непосредственно. Они объявляются в классе родительского элемента с использованием статического метода `DependencyProperty.RegisterAttached()`.

###### Определение присоединенного свойства
Чтобы объявить присоединенное свойство, необходимо выполнить следующие шаги:

1. Создание поля **`DependencyProperty`**: Это поле будет хранить информацию о присоединенном свойстве. Например:
   ```cs
   public static readonly DependencyProperty MyProperty =
    DependencyProperty.RegisterAttached(
        "My",
        typeof(string),
        typeof(MyClass), // класс, который определяет это свойство
        new PropertyMetadata(default(string)));
   ```
2. Создание методов доступа: Для работы с присоединенным свойством необходимо определить статические методы `Get` и `Set`, которые будут использоваться для получения и установки значений этого свойства:
   ```cs
   public static void SetMy(DependencyObject element, string value)
   {
       element.SetValue(MyProperty, value);
   }

   public static string GetMy(DependencyObject element)
   {
       return (string)element.GetValue(MyProperty);
   }
   ```

###### Использование в XAML
В XAML присоединенные свойства задаются с использованием синтаксиса `<attached property provider type>.<property name>`. Например, если у вас есть класс `MyClass`, который определяет присоединенное свойство `My`, его можно использовать следующим образом:
```xml
<SomeParentElement local:MyClass.My="SomeValue" />
```

Здесь `local` — это пространство имен, в котором определен класс `MyClass`.

###### Пример
Для наглядности рассмотрим пример использования присоединенного свойства для управления расположением дочерних элементов внутри контейнера:
```cs
public static readonly DependencyProperty DockProperty =
    DependencyProperty.RegisterAttached(
        "Dock",
        typeof(Dock),
        typeof(DockPanel),
        new PropertyMetadata(Dock.Top));

public static void SetDock(UIElement element, Dock value)
{
    element.SetValue(DockProperty, value);
}

public static Dock GetDock(UIElement element)
{
    return (Dock)element.GetValue(DockProperty);
}
```

В этом примере `DockPanel` использует присоединенное свойство `Dock`, чтобы определить, как дочерние элементы должны быть расположены внутри него.

Присоединенные свойства являются мощным инструментом для расширения функциональности элементов управления без необходимости их изменения или создания новых классов.[^krzDsBzYR6ekyDXmIt0ySw]

[^krzDsBzYR6ekyDXmIt0ySw]: https://www.perplexity.ai/search/opredelite-kakim-obrazom-priso-krzDsBzYR6ekyDXmIt0ySw

</details>

Пример работы приложения:

![Picture 1](./img/67b44dc65040133e8429ef84-1.png)

Для дочернего элемента необходимо указать привязку по вертикали (`Canvas.Top` или `Canvas.Bottom`) и привязку по горизонтали (`Canvas.Left` или `Canvas.Right`). Также можно (не обязательно) задать ширину и высоту элемента с помощью атрибутов `Width` и `Height`.

Таким образом, положение дочернего элемента управления можно задать относительно любого угла окна. Например, в следующем примере положение кнопки задано относительно нижнего правого угла окна:
```xml
<Canvas>
  ...
  <Button Canvas.Right="10" Canvas.Bottom="10" Content="Зарегистрироваться" />
</Canvas>
```

![Picture 2](./img/67b44dc65040133e8429ef84-2.png)

Порядок объявления дочерних элементов управления определяет порядок их вывода на экран. В приведенном выше примере кнопка выводится перед текстовыми полями, т.к. она была объявлена в файле XAML последней.

#### Диспетчер компоновки WrapPanel
Панель `WrapPanel` выводит дочерние элементы последовательно слева направо (либо сверху вниз, если для атрибута `Orientation` установлено значение “Vertical”) и при достижении границы окна переходит на новую строку (столбец). При изменении размеров окна панель перераспределяет компоненты таким образом, чтобы они находились в окне.

Рассмотрим панель `WrapPanel` со следующим содержимым:
```xml
<WrapPanel>
  <Label Content="Регистрация пользователя" />
  <Label Content="ФИО" />
  <TextBox Width="200" />
  <Label Content="Email" />
  <TextBox Width="200" />
  <Button Content="Зарегистрироваться" />
</WrapPanel>
```

Пример работы приложения:

![Picture 3](./img/67b44dc65040133e8429ef84-3.png)

#### Диспетчер компоновки StackPanel
Панель `StackPanel` располагает содержащиеся в нем элементы управления либо в вертикальном столбце (по умолчанию), либо в горизонтальной строке (если в атрибут `Orientation` записано значение “Vertical”). Если в панель `StackPanel` добавлено больше элементов управления, чем может быть отображено по ширине/высоте `StackPanel`, лишние элементы обрезаются и не отображаются.

При выводе элементов сверху вниз элементы по умолчанию растягиваются по горизонтали. Это поведение можно изменить с помощью свойств `HorizontalAlignment` и `VerticalAlignment`.

Рассмотрим панель `StackPanel` со следующим содержимым:
```xml
<StackPanel HorizontalAlignment="Center">
  <Label Content="Регистрация пользователя" />
  <Label Content="ФИО" />
  <TextBox Width="200" />
  <Label Content="Email" />
  <TextBox Width="200" />
  <Button Content="Зарегистрироваться" />
</StackPanel>
```
Пример работы приложения:

![Picture 4](./img/67b44dc65040133e8429ef84-4.png)

#### Диспетчер компоновки DockPanel
Панель `DockPanel` пристыковывает дочерние элементы к различным сторонам панели: `Top`, `Bottom`, `Left`, `Right`. Атрибут `LastChildFill` по умолчанию имеет значение `True`, что означает, что последний дочерний элемент управления будет занимать всё оставшееся пространство панели.

Рассмотрим панель `DockPanel` со следующим содержимым:
```xml
<DockPanel LastChildFill="False">
  <Label DockPanel.Dock="Top" Content="Регистрация пользователя" />
  <Label DockPanel.Dock="Left" Content="ФИО" />
  <TextBox DockPanel.Dock="Left" Width="200" />
  <Label DockPanel.Dock="Right" Content="Email" />
  <TextBox DockPanel.Dock="Right" Width="200" />
  <Button DockPanel.Dock="Bottom" Content="Зарегистрироваться" />
</DockPanel>
```

Пример работы приложения:

![Picture 5](./img/67b44dc65040133e8429ef84-5.png)

#### Диспетчер компоновки Grid
Подобно HTML-таблице, панель `Grid` может состоять из набора ячеек, каждая из которых имеет свое содержимое. При определении панели `Grid` выполняются следующие шаги:
1. Определение и конфигурирование каждого столбца.
2. Определение и конфигурирование каждой строки.
3. Назначение содержимого каждой ячейке сетки с использованием синтаксиса присоединяемых свойств.

Если не определить никаких строк и столбцов, то по умолчанию панель `Grid` будет состоять из одной ячейки, занимающей всю поверхность окна. Кроме того, если не указать ячейку для дочернего элемента, то он разместится в столбце 0 и строке 0.

Определение столбцов и строк выполняются за счет использования элементов `<Grid.ColumnDefinitions>` и `<Grid.RowDefinitions>`, которые содержат коллекции элементов `<ColumnDefinition>` и `<RowDefinition>`, соответственно.

Каждый дочерний элемент прикрепляется к ячейке сетки, используя присоединяемые свойства `Grid.Row` и `Grid.Column`. Левая верхняя ячейка определяется с помощью `Grid.Column="0"` и `Grid.Row="0"`.

Рассмотрим панель `Grid` со следующим содержимым:
```xml
<Grid>
  <Grid.RowDefinitions>
    <RowDefinition/>
    <RowDefinition/>
    <RowDefinition/>
    <RowDefinition/>
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition/>
    <ColumnDefinition/>
  </Grid.ColumnDefinitions>
  <Label Grid.Row="0" Grid.Column="0" Content="Регистрация пользователя" />
  <Label Grid.Row="1" Grid.Column="0" Content="ФИО" />
  <TextBox Grid.Row="1" Grid.Column="1" Width="200" />
  <Label Grid.Row="2" Grid.Column="0" Content="Email" />
  <TextBox Grid.Row="2" Grid.Column="1" Width="200" />
  <Button Grid.Row="3" Grid.Column="0" Content="Зарегистрироваться" />
</Grid>
```
Пример работы приложения:

![Picture 6](./img/67b44dc65040133e8429ef84-6.png)

Объединение ячеек осуществляется с помощью присоединяемых свойств `Grid.ColumnSpan` и `Grid.RowSpan` аналогично объединению ячеек в HTML-таблицах.

Рассмотрим панель `Grid` со следующим содержимым:
```xml
<Grid>
  <Grid.RowDefinitions>
    <RowDefinition/>
    <RowDefinition/>
    <RowDefinition/>
    <RowDefinition/>
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition/>
    <ColumnDefinition/>
  </Grid.ColumnDefinitions>
  <Label Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="2" HorizontalAlignment="Center"
  Content="Регистрация пользователя" />
  <Label Grid.Row="1" Grid.Column="0" Content="ФИО" />
  <TextBox Grid.Row="1" Grid.Column="1" Width="200" />
  <Label Grid.Row="2" Grid.Column="0" Content="Email" />
  <TextBox Grid.Row="2" Grid.Column="1" Width="200" />
  <Button Grid.Row="3" Grid.Column="0" Grid.ColumnSpan="2" HorizontalAlignment="Center"
  Content="Зарегистрироваться" />
</Grid>
```

Пример работы приложения:

![Picture 7](./img/67b44dc65040133e8429ef84-7.png)

При определении ряда можно задать его высоту с помощью атрибута `Height`, а при определении столбца можно задать его ширину с помощью атрибута `Width`. Значение этих атрибутов может быть следующим:
- `"Auto"` — высота строчки (или ширина колонки) определяется её содержимым;
- `"`*`Число`*`"` — высота строчки (или ширина колонки) равна указанному числу точек;
- `"*"` —  высота строчки (или ширина колонки) занимает всё свободное пространство. Если строчек (колонок) с таким значением атрибута несколько, то свободное пространство перераспределяется между ними.

#### Задание
Разработать приложение WPF со следующим графическим интерфейсом:

![Picture 8](./img/67b44dc65040133e8429ef84-8.png)

#### Дополнительное задание
Разработать приложение WPF со следующим графическим интерфейсом:

![Picture 9](./img/67b44dc65040133e8429ef84-9.png)

### Практическая работа "Основные элементы управления WPF"
[67b830665040133e8429efa4](https://e-learn.petrocollege.ru/mod/assign/view.php?id=369416)

#### Элемент управления Button (кнопка)
Представляет собой обычную кнопку.

![Picture 1](./img/67b830665040133e8429efa4-1.png)

Отличительные особенности:
- Событие **`Click`** – нажатие на кнопку. В атрибуте `Click` указывается название функции-обработчика этого события.
- Свойство **`IsCancel`**.  Возможные значения: `True`, `False`. Если записано  `True`, то кнопка будет срабатывать при нажатии на кнопку <kbd>Esc</kbd> в данном окне, т.е. когда пользователь хочет закрыть окно без выполнения каких-либо действий.
- Свойство **`IsDefault`**. Возможные значения: `True`, `False`. Если записано  `True`, то кнопка будет срабатывать при нажатии на кнопку <kbd>Enter</kbd> в данном окне, но только если не выделена какая-либо другая кнопка. В отличие от приложения  Windows Forms, в WPF-приложении при открытии окна не происходит автоматического выделения какого-либо элемента. Чтобы выделить первый элемент в окне, необходимо нажать кнопку <kbd>Tab</kbd>. Кнопка со свойством `IsDefault="True"` подсвечивается в окне, как будто она получила фокус. Но на самом деле кнопка не получает фокус, т.к. нажатие на клавишу «Пробел» не приводит к нажатию кнопки, а нажатие клавиши  <kbd>Tab</kbd> приводит к выделению первого элемента на странице, а не элемента, следующего за кнопкой.

#### Элемент управления ToggleButton (переключаемая кнопка)
Представляет собой кнопку, которая может находиться в двух состояниях: нажатом и отжатом.

![Picture 2](./img/67b830665040133e8429efa4-2.png)

Отличительные особенности:
- Событие **`Click`** – нажатие или отжатие кнопки. В атрибуте `Click` указывается название функции-обработчика этого события.
- Событие **`Checked`** – нажатие кнопки. В атрибуте `Checked` указывается название функции-обработчика этого события.
- Событие **`Unchecked`** – отжатие кнопки. В атрибуте `Unchecked` указывается название функции-обработчика этого события.
- Свойство **`IsChecked`** – состояние кнопки. `True` – кнопка нажата, `False` – кнопка отжата.

#### Элемент управления CheckBox (независимый переключатель)

![Picture 3](./img/67b830665040133e8429efa4-3.png)

Класс `CheckBox` является наследником от класса `ToggleButton` и наследует его свойства и события.

Для обращения к элементу управления из кода программы необходимо в XAML-коде задать для него имя в атрибуте `Name` с префиксом `x`, как это показано в примере выше. Префикс 'x:' означает пространство имен XAML, а не пространство имен WPF.

#### Элемент управления RadioButton (зависимый переключатель)

![Picture 4](./img/67b830665040133e8429efa4-4.png)

Класс `RadioButton` является наследником от класса `ToggleButton` и наследует его свойства и события.

Отличительные особенности:
- Свойство **`GroupName`** – название группы зависимых переключателей. В одном окне может быть несколько групп зависимых переключателей с разными названиями групп.

#### Элемент управления ComboBox (выпадающий список)
Элемент `ComboBox` представляет собою выпадающий список, элементы которого определены с помощью элементов `ComboBoxItem`:
```xml
<ComboBox SelectedIndex="1">
  <ComboBoxItem Content="Red" />
  <ComboBoxItem Content="Green" />
  <ComboBoxItem Content="Blue" />
</ComboBox>
```

![Picture 5](./img/67b830665040133e8429efa4-5.png)

В качестве содержимого элементов выпадающего списка можно задавать не только текст, но и другие элементы, например эллипс или прямоугольник.

#### Элемент управления ListBox (список)
Элемент `ListBox` представляет собою список, элементы которого определены с помощью элементов `ListBoxItem`:
```xml
<ListBox SelectedIndex="1">
  <ListBoxItem Content="Red" />
  <ListBoxItem Content="Green" />
  <ListBoxItem Content="Blue" />
</ListBox>
```

![Picture 6](./img/67b830665040133e8429efa4-6.png)

В качестве содержимого элементов списка можно задавать не только текст, но и другие элементы.

После заполнения элемента управления `ComboBox` (или `ListBox`) есть три способа определен выбранного в них элемента. Во-первых, если необходимо найти числовой индекс выбранного элемента, необходимо использовать свойство `SelectedIndex` (отсчет начинается с `0`; `-`1 означает отсутствие выбора). Во-вторых, если требуется получить объект, выбранный внутри списка, то используется свойство `SelectedItem`. В-третьих, `SelectedValue` позволяет получить значение выбранного объекта.

#### Элемент управления Slider
Элемент `Slider` представляет собою ползунок с минимальным значением  `Minimum`, максимальным значением `Maximum` и текущим значением `Value`.

```xml
<Slider Height="25" Width="100" Minimum="1" Maximum="100" Value="20" />
```

![Picture 7](./img/67b830665040133e8429efa4-7.png)

#### Меню
Меню в WPF представлено классом `Menu`, который может включать в себя набор объектов `MenuItem`. Каждый объект `MenuItem` в свою очередь может включать в себя другие объекты `MenuItem` и объекты `Separator` (разделитель).

Пример элемента `Menu`:
```xml
<Menu Background="White" BorderBrush="Navy" BorderThickness="1">
  <MenuItem Header="_Файл" />
    <MenuItem Header="_Открыть" />
    <MenuItem Header="_Сохранить" />
    <Separator />
    <MenuItem Header="_Закрыть" />
  </MenuItem>
  <MenuItem Header="_О программе" />
</Menu>
```

Знак подчеркивания в названиях пунктов меню указывает «горячие» клавиши для доступа к этим пунктам меню.

Пример работы приложения:

![Picture 8](./img/67b830665040133e8429efa4-8.png)

Элемент `MenuItem` может содержать и другие элементы управления, например зависимые (`RadioButton`) и независимые (`CheckBox`) переключатели:
```xml
<CheckBox Content="Предупреждать о несохраненных данных при закрытии" />
<RadioButton GroupName="codepage" Content="Windows-1251" />
<RadioButton GroupName="codepage" Content="Koi8-r" />
<RadioButton GroupName="codepage" Content="UTF-8" />
```

![Picture 9](./img/67b830665040133e8429efa4-9.png)

#### Панель инструментов
Панель инструментов в WPF представлена классом `ToolBar`, который в качестве содержимого может включать в себя коллекцию любых других элементов. Панели инструментов обычно используются как альтернативный способ активизации пунктов меню.

Пример элемента `ToolBar`:
```xml
<ToolBar>
  <Button>
    <Image Source="open.png"></Image>
  </Button>
  <Separator/>
  <Button>
    <Image Source="http://www.readyicons.com/IconSets/Sky_Light_%28Basic%29/48x48-save.png"></Image>
  </Button>
</ToolBar>
```

![Picture 10](./img/67b830665040133e8429efa4-10.png)

Кнопки содержат элементы `Image`. Первый элемент `Image` получает данные из файла *open.png*, включенного в проект. Второй элемент `Image` получает данные с веб-сайта по протоколу HTTP. Другие изображения можно выбрать, открыв в браузере адрес http://www.readyicons.com/IconSets/Sky_Light_%28Basic%29/

Для создания нескольких панелей инструментов элементы `ToolBar` необходимо поместить в элемент `ToolBarTray`.

#### Строка состояния
Строка состояния в WPF представлена классом `StatusBar`, который в качестве содержимого может включать в себя коллекцию любых других элементов, в том числе `StatusBarItem`.

Пример элемента `StatusBar`:
```xml
<StatusBar DockPanel.Dock="Bottom">
  <TextBlock Text="Сохранение документа ..." />
  <StatusBarItem HorizontalAlignment="Right" >
    <TextBlock Text="Подключение к БД: ОК" />
  </StatusBarItem>
</StatusBar>
```

Пример работы приложения:

![Picture 11](./img/67b830665040133e8429efa4-11.png)

Элемент `TextBlock` может применяться для отображения текста с добавлением форматирования: полужирный текст, подчеркнутый текст, разрывы строк и т.д.

#### Элемент управления InkCanvas
Элемент управления `InkCanvas` позволяет рисовать и редактировать линии с помощью мыши или пера. Размеры элемента управления можно задать с помощью свойств `Width` и `Height`. Свойства пера (цвет, ширину и высоту) можно настроить с помощью свойства `DefaultDrawingAttributes`:
```xml
<InkCanvas>
  <InkCanvas.DefaultDrawingAttributes>
    <DrawingAttributes Color="Red" Height="10" Width="1"/>
  </InkCanvas.DefaultDrawingAttributes>
</InkCanvas>
```

Результат выполнения данного участка программы:

![Picture 12](./img/67b830665040133e8429efa4-12.png)

Свойство `EditingMode` позволяет настроить режим редактирования: рисование (`Ink`), выбор и редактирование фигур (`Select`), удаление по точкам (`EraseByPoint`) и удаление фигур (`EraseByStroke`).

#### Обработчики событий
Для добавления обработчика для какого-либо события объекта необходимо в открывающем теге элемента написать имя события и через знак «=» имя функции-обработчика, либо выбрать команду «Новый обработчик события»:

![Picture 13](./img/67b830665040133e8429efa4-13.png)

При выборе команды «Новый обработчик события» в CS-файле, относящемся к  XAML-файлу, будет добавлена соответствующая функция:
```cs
private void MenuItem_Click(object sender, RoutedEventArgs e)
{

}
```

В обработчике можно обратиться по имени к любому объекту, для которого в  XAML-файле было определено имя с помощью атрибута `Name` или `x:Name`:
```xml
<MenuItem Name="mi_open" Header="_Открыть" Click="MenuItem_Click" />
```
```cs
private void MenuItem_Click(object sender, RoutedEventArgs e)
{
  mi_open.Background = Brushes.LightGreen;
}
```

С помощью объекта `sender`, переданного в качестве параметра, можно получить доступ к элементу управления, для которого возникло обрабатываемое событие, даже в случае, если для него не задано имя:
```cs
private void CheckBox_Click(object sender, RoutedEventArgs e)
{
  ((FrameworkElement)sender).Visibility = System.Windows.Visibility.Hidden;
}
private void CheckBox_Click(object sender, RoutedEventArgs e)
{
  MessageBox.Show(((CheckBox)sender).IsChecked.ToString());
}
```

В первом примере объект `sender` был приведен к базовому классу `FrameworkElement` для доступа к базовым свойствам, присущим всем элементам управления. Во втором случае объект `sender` был приведен к классу `CheckBox` для доступа к специфическим свойствам данного элемента управления.

Если для нескольких элементов управления определен один обработчик какого-либо события, то для определения выбранного элемента управления в коде обработчика можно использовать свойство `Tag`, доступное для всех элементов управления:
```cs
private void MenuItem_Click(object sender, RoutedEventArgs e)
{
if (((FrameworkElement)sender).Tag.ToString() == "open") MessageBox.Show("Выбрана команда 'Открыть'");
else
if (((FrameworkElement)sender).Tag.ToString() == "save") MessageBox.Show("Выбрана   команда 'Сохранить'");
}
```

Наиболее часто используемые события:

| Событие | Описание
-- | --
`Click` | Происходит при нажатии на элемент управления
`MouseMove` | Происходит, когда указатель мыши совершает движение по этому элементу
`MouseEnter` | Происходит, когда указатель мыши входит в границы данного элемента
`MouseLeave` | Происходит, когда указатель мыши покидает границы данного элемента
`MouseDown` | Происходит при нажатии кнопки мыши, если указатель мыши находится на элементе
`MouseUp` | Происходит, когда кнопка мыши отпускается на элементе
`MouseWheel` | Происходит при прокрутке пользователем колесика мыши, если указатель мыши находится на элементе
`KeyDown` | Происходит при нажатии клавиши, если элемент имеет фокус
`KeyUp` | Происходит при отжатии клавиши, если элемент имеет фокус

#### Задание 1
Разработать WPF-приложение с меню, панелью инструментов и строкой состояния. С помощью пунктов меню пользователь может изменять цвет фона окна, получить информацию о разработчике, а также закрыть окно. Кнопки панели инструментов дублируют команды меню. При наведении на пункты меню или кнопки панели инструментов в строке состояния отображается информация об этих элементах управления.

#### Задание 2
Разработать WPF-приложение «Графический редактор» с выпадающим списком для выбора цвета кисти, ползунком для выбора размеров кисти и зависимыми переключателями для выбора режима работы: «рисование», «редактирование», «удаление».

### Практическая работа Привязка данных
[67b9a0e15040133e8429efb4](https://e-learn.petrocollege.ru/mod/assign/view.php?id=369417)

Ознакомиться с лекцией и выполнить задания

<dfn title="привязка данных">Привязка данных</dfn> (data  binding) в графической системе WPF представляет собою отношение, которое сообщает WPF о необходимости извлечения данных из свойства исходного объекта (Source) и использования её для задания значения некоторого свойства целевого объекта (Target) (и, в некоторых случаях, наоборот).

Объектом-источником может быть как элемент WPF, так и объект ADO.NET или пользовательский объект, хранящий данные. В данной лабораторной работе рассматривается связывание элементов управления WPF.

Рассмотрим пример приложения из двух элементов управления: ползунка (`Slider`) и текстового блока (`TextBlock`). При изменении положения ползунка размер шрифта текстового блока должен меняться. Такое поведение можно реализовать за счет обработки события изменения положения ползунка `ValueChaned`:

![Picture 1](./img/67b9a0e15040133e8429efb4-1.png)

Как видно из исходного кода, возникает необходимость проверки существования объекта `Message`, т.к. первый вызов обработчика `Slider_ValueChanged` происходит в момент обработки элемента `Slider` XAML-файла, когда элемент `TextBlock` еще не обработан и, соответственно, объект `Message` еще не создан. Второй проблемой является несоответствие начального значения ползунка и начального размера шрифта.

Для решения поставленной задачи с помощью привязки данных, необходимо  указать в качестве значения свойства `FontSize` текстового блока следующее выражение привязки:
```cs
{Binding ElementName=SliderFontSize, Path=Value}`
```

Выражение привязки данных задается в виде расширения разметки XAML в фигурных скобках.

Составляющие выражения привязки:
- **`Binding`** – означает, что будет создан объект класса `System.Windows.Data.Binding`
- **`ElementName`** – имя исходного объекта,
- **`Path`** – имя свойства (или путь до свойства) исходного объекта. Пример пути до свойства: `Background.Opacity`

![Picture 2](./img/67b9a0e15040133e8429efb4-2.png)

В данном примере отсутствуют проблемы, обнаруженные в предыдущем примере. Начальные значения связанных свойств будут согласованы даже в том случае, если элемент `TextBlock` будет предшествовать элементу `Slider`.

#### Задание 1
Проверьте реакцию среды разработки на неверные значения параметров `ElementName` и  `Path`. Проанализируйте сообщения, которые выводятся в окне вывода (*Вид* → *Вывод*) при построении и при запуске приложения.

#### Режимы привязки
В выражении привязки с помощью параметра `Mode` можно задать одно из следующих пяти значений режима привязки:
1) `OneWay` – целевое свойство обновляется при изменении исходного свойства.

   ![Picture 3](./img/67b9a0e15040133e8429efb4-3.png)

2) `OneTime` – первоначально значение исходного свойства копируется в целевое свойство, но дальнейшие изменения исходного свойства не учитываются.

   ![Picture 4](./img/67b9a0e15040133e8429efb4-4.png)

3) `TwoWay` — целевое свойство обновляется при изменении исходного свойства, исходное свойство обновляется при изменении целевое свойства.

   ![Picture 5](./img/67b9a0e15040133e8429efb4-5.png)

4) `OneWayToSource` – исходное свойство обновляется при изменении целевое свойства.

   ![Picture 6](./img/67b9a0e15040133e8429efb4-6.png)

5) `Default` – значение по умолчанию. Если целевое свойство устанавливается пользователем (например, `TextBox.Text`, `Slider.Value`, `CheckBox.IsChecked`, …), то это `TwoWay`, в остальных случаях – это `OneWay`.

Пример выражения привязки с параметром Mode: `{Binding ElementName=slider1, Path=Value, Mode=OneTime}`.

#### Задание 2
Запустите приложение со следующим XAML-кодом:
```xml
<TextBox x:Name="t1" />
<TextBox x:Name="t2" Text="{Binding ElementName=t1, Path=Text}" />
<Slider x:Name="slider1" />
<Slider x:Name="slider2" Value="{Binding ElementName=slider1, Path=Value}" />
```

Определите различие в поведении полей `t1` и `t2` и модифицируйте код, чтобы устранить это различие.

#### Задание 3
Дополните пример №2 текстовым полем ввода `TextBox`, в котором пользователь может ввести размер шрифта, и задайте выражения привязки таким образом, чтобы значение ползунка, текст текстового поля и размер шрифта текстового блока соответствовали друг другу.

#### Задание 4
Модифицируйте приложения, разработанные в предыдущей лабораторной работе: удалите  как можно больше обработчиков событий и реализуйте ту же функциональность приложения с помощью привязки данных.

Подсказки:

Свойство `EditingMode` (тип данных `InkCanvasEditingMode`) элемента управления `InkCanvas` нельзя напрямую связать с текстовым свойством выпадающего списка `ComboBox` или списка `ListBox`, т.к. в этом случае будет несовпадение типов. Для привязки данных необходимо, чтобы тип элементов списка совпадал с типом свойства `EditingMode`. Для этой цели необходимо добавить в  ресурсы окна приложения (элемент `Windows.Resources`) массив (элемент `x:Array`) элементов типа `InkCanvasEditingMode` (атрибут `x:Type`), данному ресурсу необходимо задать ключ (атрибут `x:Key`), который необходимо указать в свойстве `ItemSource` списка `ListBox` или выпадающего списка `ComboBox`. В этом случае можно будет осуществить привязку данных между свойством `EditingMode` и выделенным элементом списка:
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyEditingModes" x:Type="{x:Type InkCanvasEditingMode}">
      <x:Static Member="InkCanvasEditingMode.Ink"/>
      <x:Static Member="InkCanvasEditingMode.Select"/>
      <x:Static Member="InkCanvasEditingMode.EraseByPoint"/>
      <x:Static Member="InkCanvasEditingMode.EraseByStroke"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas EditingMode="{Binding ElementName=lbEditingModes, Path=SelectedValue}" />
    <ListBox x:Name="lbEditingModes" ItemsSource="{StaticResource MyEditingModes}" />
  </StackPanel>
</Window>
```

Аналогичным образом можно задать привязку данных между свойством  `DefaultDrawingAttributes` и выделенным элементом списка (в данном случае массив  `x:Array` будет содержать элементы типа `DrawingAttributes`):
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyDrawingAttributes" x:Type="{x:Type DrawingAttributes}">
      <DrawingAttributes Color="Red" Width="3" Height="3"/>
      <DrawingAttributes Color="Green" Width="10" Height="10"/>
      <DrawingAttributes Color="Blue" Width="15" Height="15"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas DefaultDrawingAttributes="{Binding ElementName=lbColors, Path=SelectedValue}" />
    <ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}" />
  </StackPanel>
</Window>
```

Недостатком последнего примера является то, что все элементы в списке выводятся с текстом «System.Windows.Ink.DrawingAttributes». Для придания элементам списка осмысленного содержания, необходимо определить шаблон элементов (`ListBox.ItemTemplate`), в котором определить, каким образом элементы списка будут отображены на экране (например, в виде текстового блока, содержащего поле `Color`):
```xml
<ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}">
  <ListBox.ItemTemplate>
    <DataTemplate>
      <TextBlock Text="{Binding Path=Color}"></TextBlock>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

### Практическая работа Стили WPF
[67b9cee55040133e8429efb6](https://e-learn.petrocollege.ru/mod/assign/view.php?id=369418)

Ознакомиться с лекцией и выполнить задания

Стили WPF позволяют определять внешний вид и поведение для группы элементов управления. Рассмотрим пример WPF-приложения:

![Picture 1](./img/67b9cee55040133e8429efb6-1.png)

Для трех элементов управления повторяются одни и те же атрибуты с одинаковыми значениями. Как при программировании наличие повторяющегося кода является плохим стилем, так и при разработке  WPF-интерфейса повторение участков XAML-кода не приветствуется. В данном случае правильным решением является определение внешнего вида кнопки с помощью стиля и задание этого стиля для трех кнопок. По функциональности стили похожи на каскадные таблицы стилей CSS для HTML-файлов.

Обычно стили, как и другие ресурсы приложения, определяются в ресурсах окна:
```xml
<Window.Resources>
  ...
  <Style>
  </Style>
  ...
</Window.Resources>
```

Свойство `Resources` объявлено для класса `FrameworkElement`, поэтому ресурсы можно объявить практически для любого элемента управления:
```xml
<StackPanel.Resources>
  ...
  <Style>
  </Style>
  ...
</StackPanel.Resources>
<Button.Resources>
  ...
  <Style>
  </Style>
  ...
</Button.Resources>
```

Область действия стиля, объявленного в ресурсах какого-либо элемента управления, распространяется только на этот элемент управления и его дочерние элементы управления. Следует учесть, что статический ресурс должен быть определен в коде разметки **перед** ссылкой на него.

Стиль определяется с помощью элемента `Style` и может использоваться для определения:
- значений атрибутов;
- обработчиков событий;
- триггеров, меняющих атрибуты элемента управления при возникновении каких-либо событий или при изменении каких-либо свойств;
- шаблонов, переопределяющих внешний вид элементов управления.

Ключевые свойства, определенные в классе `Style`:
- `TargetType` – тип элемента, для которого определяется данный стиль;
- `BasedOn` – родительский стиль (позволяет задавать иерархические стили);
- `Setters` – коллекция объектов `Setter` или `EventSetter`, которые предназначены для установления значений свойств и обработчиков событий;
- `Triggers` – коллекция триггеров;
- `Resourses` – коллекция ресурсов, которые необходимо использовать с ресурсами.

Объект `Setter` определяет значение одного свойства элемента управления:
```xml
<Setter Property="НАЗВАНИЕ_СВОЙСТВА" Value="ЗНАЧЕНИЕ" />
```

Рассмотрим модифицированную версию примера 1 с использованием стилей:

![Picture 2](./img/67b9cee55040133e8429efb6-2.png)

Допускается не указывать элемент `Style.Setters`:
```xml
<Style TargetType="Button">
  <Setter Property="Background" Value="DarkBlue" />
  <Setter Property="Foreground" Value="White" />
  <Setter Property="FontFamily" Value="Verdana" />
  <Setter Property="Padding" Value="5" />
  <Setter Property="Margin" Value="5" />
</Style>
```

В данном примере стиль был применен ко всем кнопкам окна (тип элементов управления определен в атрибуте `TargetType`). Если для элемента `Style` определить атрибут `x:Key` с именем стиля, то данный стиль будет определен только к тем кнопкам, для которых указано имя стиля в атрибуте `Style` с помощью расширения разметки `StaticResource`:
```xml
Style="{StaticResource ResourceKey=DocButton}"
```

Пример стиля, который применяется к трем кнопкам и не применяется к кнопке «Закрыть».

![Picture 3](./img/67b9cee55040133e8429efb6-3.png)

Допускается вместо `{StaticResource ResourceKey=DocButton}` указывать `{StaticResource DocButton}`, т.к. `ResourceKey` является единственным параметром для расширения разметки `StaticResource`.

#### Задание 1
Проверьте, какое значение имеет больший приоритет: значение свойства, указанное в стиле, или значение атрибута элемента.

Свойства `BasedOn` класса `Style` позволяет определять иерархические стили. В этом свойстве с помощью расширения разметки `StaticResource` указывается родительский стиль. Дочерний стиль наследует все свойства родительского стиля, которые он может дополнить или переопределить. Пример определения дочернего стиля `ActiveDocButton` на основе родительского стиля `DocButton`.

![Picture 4](./img/67b9cee55040133e8429efb6-4.png)

Объект `EventSetter` определяет имя функции-обработчика для события:
```xml
<EventSetter Event="НАЗВАНИЕ_СОБЫТИЯ" Handler="ИМЯ_ФУНКЦИИ" />
```

Пример задания одного обработчика для всех кнопок окна:

![Picture 5](./img/67b9cee55040133e8429efb6-5.png)

#### Задание 2
Модифицируйте WPF-приложение, разработанное в 3-ей лабораторной работе: используйте стили для однотипных элементов управления.

#### Задание 3
Разработайте приложение `MultiEdit` для одновременной работы с несколькими текстами. Окно должно быть разделено на две части с одинаковыми градиентами. В каждой части окна должно быть несколько многострочных  текстовых полей: одно из них большого размера с крупным шрифтом, а остальные маленького размера с мелким шрифтом. То текстовое окно, в котором пользователь набирает текст, должно быть большим, остальные текстовые поля должны быть маленькими. Внешний вид однотипных элементов управления должен определяться с помощью стилей.

Изменить стиль элемента управления в коде можно следующим образом:
```cs
(sender as FrameworkElement).Style = (Style)Resources["ИМЯ_СТИЛЯ"];
```

### ПР04-4 LINQ в Entity Framework. Поиск и фильтрация
[67bc02e15040133e8429efbd](https://e-learn.petrocollege.ru/mod/assign/view.php?id=369422)

Доработать свое приложение для выполнения основных операций поиска и фильтрации. Добавить:
1) Поиск с помощью `Where`:
   - по полному содержимому поля;
   - по частичному совпадению содержимого поля;
   - по названию с буквы Х, где сама буква Х задается пользователем.
2) Отсортировать:
   - по значению одного поля по возрастанию или убыванию (это задает пользователь);
   - по значениям пары полей одной таблицы.
3) Сгруппировать по какому-либо признаку (для таблиц, связанных отношением один-ко-много)
4) Подсчитать количество записей удовлетворяющих какому-либо условию (среднее значение, сумму — то, что применимо в вашем варианте).

## КП
[67bd7f205040133e8429efca](https://e-learn.petrocollege.ru/course/view.php?id=6620#section-2)

### Курсовое проектирование

**Инструкция по выбору темы курсового проекта**:
1) Изучите предметные области, представленные ниже в файле. Выберите предметную область, которая Вам наиболее понятна и интересна или придумайте свою.
2) Отметьте выбранный вариант задания в гугл форме
3) Приступайте к выполнению

В качестве БД обязательно используем базу данных сервера MS SQL.

**В описании дано лишь общее описание предметной области. Дальнейшее — это ваше видение. В результате должно получиться полноценное коммерческое приложение. Интерфейс — с использованием технологии WPF.**

**Результат выполнения курсовой работы**:
1) пояснительная записка с описанием процесса разработки и включающая все полученные результаты:
   - а) схему БД (ER-диаграмма)
   - б) схему классов (диаграмма классов приложения — модель данных) с листингами классов
   - в) схема взаимодействия пользовательских форм (страниц)
   - г) описание стиля оформления (руководство по стилю) и листинг стилей
   - д) листинги модулей (не вошедшие в предыдущие пункты)
   - е) скриншоты в процессе разработки и в процессе выполнения приложения. Объем записки - не менее 35 листов
2) архив с исходным проектом разработанного приложения.
3) презентация для защиты проекта

### Темы работ

1. **Кадровое агентство**:
   - **Пользователи**: соискатели, работодатели, сотрудники агентства.
   - **Данные**: резюме соискателей, вакансии работодателей, информация о сотрудниках агентства, история взаимодействия с клиентами.
   - **Операции**: просмотр и редактирование резюме и вакансий, назначение собеседований, управление задачами и проектами, формирование отчётов о работе агентства.
2. **Отдел кадров предприятия**:
   - **Пользователи**: сотрудники отдела кадров, руководители подразделений, работники предприятия.
   - **Данные**: личные дела сотрудников, графики отпусков, табели учёта рабочего времени, приказы по личному составу.
   - **Операции**: оформление приёма на работу и увольнения, ведение кадрового документооборота, учёт рабочего времени и отпусков, формирование отчётности по кадрам.
3. **Магазин по продаже бытовой техники**:
   - **Пользователи**: покупатели, продавцы-консультанты, менеджеры по продажам.
   - **Данные**: каталог товаров, цены, наличие на складе, история покупок клиентов.
   - **Операции**: добавление и удаление товаров из каталога, изменение цен и характеристик товаров, оформление заказов, формирование отчётов по продажам.
4. **Компьютерная фирма**:
   - **Пользователи**: клиенты, сотрудники фирмы.
   - **Данные**: список услуг и товаров, прайс-лист, заказы клиентов, история обслуживания.
   - **Операции**: предоставление информации об услугах и товарах, оформление заявок на ремонт и обслуживание компьютеров, контроль выполнения заказов, формирование отчётов о деятельности фирмы.
5. **Компания автосервиса**:
   - **Пользователи**: владельцы автомобилей, мастера-приёмщики, механики.
   - **Данные**: информация о клиентах, записи на обслуживание и ремонт, история ремонтов, запчасти и расходные материалы.
   - **Операции**: запись на обслуживание и ремонт, контроль сроков и качества работ, формирование счетов и актов выполненных работ, управление запасами запчастей.
6. **Авиакомпания**:
   - **Пользователи**: пассажиры, агенты по бронированию, пилоты и бортпроводники.
   - **Данные**: расписание рейсов, тарифы и скидки, бронирование билетов, регистрация пассажиров, история полётов.
   - **Операции**: продажа билетов, бронирование мест, регистрация на рейс, контроль посадки на самолёт, формирование отчётов о пассажиропотоке.
7. **Скорая помощь**:
   - **Пользователи**: врачи и фельдшеры, диспетчеры, пациенты.
   - **Данные**: вызовы скорой помощи, истории болезни пациентов, отчёты о работе бригад.
   - **Операции**: приём вызовов, направление бригад на вызов, контроль состояния пациентов, формирование отчётов о работе скорой помощи.
8. **Автотранспортное предприятие**:
   - **Пользователи**: водители, диспетчеры, механики, руководство предприятия.
   - **Данные**: маршруты движения, расписание рейсов, техническое состояние транспорта, заявки на ремонт.
   - **Операции**: планирование маршрутов, контроль за движением транспорта, управление техническим обслуживанием, формирование отчётов о работе предприятия.
9. **Личная библиотека**:
   - **Пользователи**: владелец библиотеки, читатели.
   - **Данные**: книги, журналы, аудио- и видеоматериалы, электронные книги.
   - **Операции**: поиск и выдача книг, учёт выдачи и возврата, формирование списка прочитанных книг.
10. **Экспорт сырья**:
    - **Пользователи**: производители сырья, экспортёры, таможенные органы.
    - **Данные**: объёмы производства, контракты на экспорт, таможенные декларации, сертификаты качества.
    - **Операции**: заключение контрактов на экспорт, оформление таможенных документов, контроль поставок, формирование отчётов об экспорте.
11. **Система управления складом (WMS)**
    - **Пользователи**: кладовщики, менеджеры склада, операторы системы.
    - **Данные**: товары на складе, их расположение, информация о поставщиках, заказы клиентов.
    - **Операции**: приёмка товаров, размещение на складе, комплектация заказов, инвентаризация, формирование отчётов о работе склада.
12. **Платформа для онлайн-обучения**
    - **Пользователи**: преподаватели, студенты, администраторы платформы.
    - **Данные**: курсы, расписание занятий, учебные материалы, результаты тестов и экзаменов.
    - **Операции**: регистрация на курсы, просмотр расписания, доступ к учебным материалам, выполнение заданий, тестирование, выставление оценок, формирование отчётов об успеваемости студентов.
13. **Система бронирования гостиниц**
    - **Пользователи**: гости, администраторы гостиниц, агенты по бронированию.
    - **Данные**: номера, тарифы, свободные даты, отзывы гостей.
    - **Операции**: бронирование номеров, изменение бронирования, отмена бронирования, оплата проживания, формирование отчётов о загрузке гостиницы.
14. **Сервис по подбору медицинских специалистов**
    - **Пользователи**: пациенты, медицинские специалисты, администраторы сервиса.
    - **Данные**: врачи, клиники, услуги, цены, отзывы пациентов.
    - **Операции**: поиск врачей по специализации и местоположению, запись на приём, оплата услуг, оставление отзывов, формирование рейтингов специалистов.
15. **Система учёта библиотечных фондов**
    - **Пользователи**: библиотекари, читатели, администраторы системы.
    - **Данные**: книги, авторы, издательства, категории, местоположение книг в библиотеке.
    - **Операции**: выдача книг читателям, возврат книг, учёт экземпляров, поиск книг по автору, названию или категории, формирование списков литературы по запросу читателей.
16. **Платформа для организации мероприятий**
    - **Пользователи**: организаторы, участники, подрядчики.
    - **Данные**: мероприятия, билеты, программы, контакты участников и подрядчиков.
    - **Операции**: планирование мероприятий, продажа билетов, рассылка приглашений, контроль за ходом подготовки, взаимодействие с участниками и подрядчиками, формирование отчётности о мероприятиях.
17. **Система контроля доступа в помещения**
    - **Пользователи**: сотрудники, посетители, охранники.
    - **Данные**: карты доступа, время входа и выхода, события системы безопасности.
    - **Операции**: предоставление карт доступа сотрудникам и посетителям, регистрация событий системы безопасности, формирование отчётов о доступе в помещения.
18. **Онлайн-сервис для заказа продуктов**
    - **Пользователи**: клиенты, курьеры, администраторы сервиса.
    - **Данные**: продукты, магазины, доставка, цены.
    - **Операции**: заказ продуктов через сайт или мобильное приложение, отслеживание статуса заказа, оплата покупки, формирование истории заказов.
19. **Система мониторинга транспортных средств**
    - **Пользователи**: водители, диспетчеры, механики.
    - **Данные**: автомобили, маршруты, скорость, расход топлива, техническое состояние.
    - **Операции**: отслеживание местоположения и состояния автомобилей, управление маршрутами, контроль расхода топлива, диагностика неисправностей, формирование отчётов о работе транспорта.
20. **Платформа для проведения опросов и исследований**
    - **Пользователи**: респонденты, исследователи, аналитики.
    - **Данные**: вопросы, ответы, демографические данные респондентов.
    - **Операции**: проведение опросов и анкетирования, анализ результатов, формирование отчётов и рекомендаций.

### Задание 1. Результат проектирования структуры классов и БД
[67c01a5c5040133e8429f027](https://e-learn.petrocollege.ru/mod/assign/view.php?id=303171)

Приложите сюда результат проектирования структуры классов вашего приложения и структуры БД вашего проекта для своевременного согласования с заказчиком. Это позволит вам на ранних сроках выяснить возможные неточность в понимании предметной области и избежать в дальнейшем ошибок и переработок.

### Задание 2. Результат разработки форм авторизации, главной формы и форм-меню
[67c02b425040133e8429f02b](https://e-learn.petrocollege.ru/mod/assign/view.php?id=303172)

Приложите сюда результат разработки начального приложения, включающего форму авторизации, главную форму, формы меню. Возможно. часть функций еще не реализована. Предъявление и согласование с заказчиком приложения на ранних сроках позволит вам быть уверенным, что вы разрабатываете именно то, что необходимо заказчику

### Задание 3. Результат разработки приложения
[67c142025040133e8429f041](https://e-learn.petrocollege.ru/mod/assign/view.php?id=303173)

Приложите сюда результат разработки приложения, включающего основной функционал. Возможно, часть функций еще не реализована, но это уже не большая часть функционала, не сильно влияющая на общее впечатление от приложения. Предъявление и согласование с заказчиком приложения на данном этапе позволит вам получить обратную связь от Заказчика и вовремя исправить недостатки приложения.

### Задание 4. Итоговое приложение
[67c6986e5040133e8429f0cb](https://e-learn.petrocollege.ru/mod/assign/view.php?id=303174)

Приложите сюда архив с готовым приложением.

### Задание 5. Курсовой проект (пояснительная записка + презентация)
[67c698e25040133e8429f0cd](https://e-learn.petrocollege.ru/mod/assign/view.php?id=303175)

Приложите сюда пояснительную записку к курсовому проекту и презентацию.

### Задание для КП
[67c93ade5040133e8429f0e5](https://e-learn.petrocollege.ru/mod/resource/view.php?id=303176)

### Примерное ТЗ и описание предметной области
[67c93bc75040133e8429f0e6](https://e-learn.petrocollege.ru/mod/resource/view.php?id=369437)

#### Описание предметной области

Разработка модулей программного обеспечения для компьютерных систем

Основная цель учёта заявок на ремонт оборудования — эффективное и оперативное осуществление ремонтных работ с минимизацией простоев и удовлетворением запросов клиентов или сотрудников. Эта предметная область широко используется в различных сферах деятельности, таких как сервисные услуги, производство, информационные технологии и другие.

Предметная область учёта заявок на ремонт оборудования касается процесса подачи, обработки и учёта заявок на ремонт различного оборудования.

В данной области включены следующие основные составляющие:

1. Заявка на ремонт: это информация, предоставленная клиентом или сотрудником о неисправности оборудования, которое требует ремонта. Заявка может содержать данные о типе оборудования, его серийном номере, описании проблемы и другой важной информации.
2. Регистрация заявки: этот процесс включает приём и регистрацию заявки в системе учёта. Важными аспектами регистрации являются присвоение уникального идентификатора заявке, сохранение информации о заявке и её приоритете.
3. Обработка заявки: процесс, включающий анализ заявки, определение её приоритетности и назначение исполнителя (ремонтного специалиста) для задачи. В процессе обработки может потребоваться дополнительная информация или уточнение деталей проблемы у клиента или сотрудника.
4. Исполнение заявки: фактическое выполнение ремонта оборудования. В этом этапе назначенный исполнитель ремонтирует оборудование, вносит необходимые изменения или заменяет неисправные компоненты. Важно отметить, что на этом этапе могут возникать необходимость заказа запчастей или координации работ с другими специалистами.
5. Отчётность и информирование: важной составляющей учёта заявок на ремонт является фиксация и отчёт о выполненной работе. После завершения ремонта, исполнитель должен предоставить отчёт о проделанной работе, включая информацию о затраченных ресурсах (время, материалы, стоимость), причине неисправности и оказанной помощи.
6. Мониторинг и анализ: этот этап предполагает контроль и анализ процесса учёта заявок на ремонт. Важно отслеживать и анализировать время обработки заявок, качество выполненных работ, расходы и прочие параметры, которые могут помочь в оптимизации и улучшении процесса.

На этапе исполнение заявки: фактическое выполнение ремонта оборудования.

Назначенный исполнитель ремонтирует оборудование, вносит необходимые изменения или заменяет неисправные компоненты. Важно отметить, что на этом этапе могут возникать необходимость заказа запчастей или координации работ с другими специалистами.

Необходимо добавить в функционал программного модуля еще одну роль – менеджера, который будет выполнять роль консультанта при возникающих проблемах с ремонтом оборудования и не выполнении ремонта в срок. При необходимости исполнитель заявки на ремонт может обратиться за помощью при возникновении невозможности выполнения ремонта.

Менеджер имеет право:
1. привлекать других специалистов к выполнению ремонта;
2. продлевать срок выполнения заявки с согласованием клиента.

Также по требованиям заказчика необходимо отслеживать качество работы по отзывам. В функционал программного модуля в этих целях необходимо добавить генерацию QR-кода для оценки работы сервиса (при сканировании кода в телефоне выдаётся ссылка на гугл-форму с опросом ).

#### Техническое задание

1. Общие сведения

    1.1. Наименование проекта: Разработка программного модуля для учета заявок на ремонт оборудования.

    1.2. Заказчик: ООО "Техносервис".

    1.3. Исполнитель: Компания "IT-Решения".

2. Функциональные требования

    2.1. Возможность добавления заявок в базу данных с указанием следующих параметров:
    - Номер заявки;
    - Дата добавления;
    - Оборудование, которое требует ремонта;
    - Тип неисправности;
    - Описание проблемы;
    - Клиент, который подал заявку;
    - Статус заявки (в ожидании, в работе, выполнено).

    2.2. Возможность редактирования заявок:
    - Изменение этапа выполнения (выполнено, в работе, не выполнено);
    - Изменение описания проблемы;
    - Изменение, ответственного за выполнение работ.

    2.3. Возможность отслеживания статуса заявки:
    - Отображение списка заявок;
    - Получение уведомлений о смене статуса заявки;
    - Поиск заявки по номеру или по параметрам.

    2.4. Возможность назначения ответственных за выполнение работ:
    - Добавление исполнителя к заявке;
    - Отслеживание состояния работы и получение уведомлений о ее завершении;
    - Исполнитель может добавлять комментарии на форме заявки.

    2.5. Расчет статистики работы отдела обслуживания:
    - Количество выполненных заявок;
    - Среднее время выполнения заявки;
    - Статистика по типам неисправностей.

3. Нефункциональные требования
    3.1. Кроссплатформенность:
    - Поддержка работы на ОС семейства Windows.

    3.2. Безопасность:
    - Логин и пароль для доступа к приложению;
    - Доступ к данным должен быть ограничен в зависимости от роли пользователя.

    3.3. Удобство использования:
    - Простой и интуитивный интерфейс;
    - Информативные уведомления и подсказки.
